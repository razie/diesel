function el(e) {
    return document.querySelector(e)
}

function on(e, t, r) {
    el(e).addEventListener(t, r, !1)
}

function show(e) {
    el(e).style.display = "block"
}

function hide(e) {
    el(e).style.display = "none"
}

function each(e, t) {
    Object.keys(e).forEach(function (r) {
        t(e[r], r)
    })
}

function save(e, t) {
    localStorage.setItem(e, JSON.stringify(t))
}

function restore(e) {
    try {
        return JSON.parse(localStorage.getItem(e))
    } catch (t) {
        return localStorage.removeItem(e), null
    }
}

function pref(e, t) {
    var r = null;
    return each(prefs, function (t, n) {
        void 0 !== t[e] && (r = n)
    }), r ? (void 0 !== t && (prefs[r][e] = t), prefs[r][e] || null) : null
}

function setup() {
    each(prefs, function (e) {
        each(e, function (e, t) {
            el("#" + t).className = e ? "active" : ""
        })
    }), on("body", "click", function (e) {
        if ("toggle" === e.target.getAttribute("data-type")) {
            var t = e.target,
                r = t.getAttribute("data-target");
            r.split(",").forEach(function (e, r) {
                var n = el("#" + e),
                    i = cache.toggled[e];
                cache.toggled[e] = i = !i, n.style.display = i ? "block" : "none", i || save("prefs", prefs), 0 === r && (t.className = i ? "active" : "")
            })
        }
    }), on("body", "click", function (e) {
        if ("pref" === e.target.getAttribute("data-type")) {
            var t = e.target,
                r = t.getAttribute("id");
            pref(r, !pref(r)), t.className = pref(r) ? "active" : "", lint()
        }
    })
}

function main() {
    var e = el("#text-intro").innerHTML;
    e = e.split("\n"), e = e.slice(1, e.length - 1), e = e.map(function (e) {
        return e.slice(6)
    }).join("\n"), editor = CodeMirror(document.body, {
        value: e,
        mode: "javascript",
        tabSize: 2,
        indentUnit: 2,
        lineNumbers: !0,
        indentWithTabs: !1
    }), setup(), lint();
    var t = null;
    editor.on("change", function () {
        t && clearTimeout(t), t = setTimeout(function () {
            t = null, lint()
        }, 200)
    })
}

function lint() {
    var e = editor.getValue(),
        t = {};
    worker || (worker = new Worker("/assets/vendor/worker.js"), worker.addEventListener("message", function (e) {
        display(JSON.parse(e.data.result))
    })), each(prefs.opts, function (e, r) {
        t[r] = e
    }), each(prefs.rev, function (e, r) {
        t[r] = !e
    }), worker.postMessage({
        task: "lint",
        code: e,
        config: t
    })
}

function makeRow(e, t) {
    var r = document.createElement("tr"),
        n = document.createElement("td");
    if (n.innerHTML = t, null !== e) {
        var i = document.createElement("td");
        i.className = "lineno", i.innerHTML = e, r.appendChild(i), r.addEventListener("mouseover", function () {
            editor.setSelection({
                line: e - 1,
                ch: 0
            }, {
                line: e - 1,
                ch: 1 / 0
            })
        }), r.addEventListener("mouseout", function () {
            editor.setCursor({
                line: e - 1,
                ch: 0
            })
        })
    } else n.className = "header", n.setAttribute("colspan", 2);
    return r.appendChild(n), r
}

function display(e) {
    showUndef(e.implieds), showUnused(e.unused), showErrors(e.errors), showMetrics(e.functions)
}

function showErrors(e) {
    var t = el("[data-type=errors]"),
        r = "";
    return t.innerHTML = "", e ? (r = 1 === e.length ? "One warning" : e.length < 11 ? NUM_TEXTS[e.length] + " warnings" : e.length + " warnings", t.appendChild(makeRow(null, r)), e.forEach(function (e) {
        null !== e && t.appendChild(makeRow(e.line, e.reason))
    }), void 0) : !1
}

function showUndef(e) {
    var t = el("[data-type=undef]"),
        r = t.innerHTML = "";
    return prefs.meta.undef && e ? (r = 1 === e.length ? "One undefined variable" : e.length < 11 ? NUM_TEXTS[e.length] + " undefined variables" : e.length + " undefined variables", t.appendChild(makeRow(null, r)), e.forEach(function (e) {
        e.line.forEach(function (r) {
            t.appendChild(makeRow(r, e.name))
        })
    }), e.length > 0) : !1
}

function showUnused(e) {
    var t = el("[data-type=unused]"),
        r = t.innerHTML = "";
    return prefs.meta.unused && e ? (r = 1 === e.length ? "One unused variable" : e.length < 11 ? NUM_TEXTS[e.length] + " unused variables" : e.length + " unused variables", t.appendChild(makeRow(null, r)), e.forEach(function (e) {
        t.appendChild(makeRow(e.line, e.name))
    }), e.length > 0) : !1
}

function showMetrics(e) {
    function t(e) {
        var t = document.createElement("p");
        t.innerHTML = e, i.appendChild(t)
    }

    function r(e) {
        var t, r = e.length;
        return e.sort(function (e, t) {
            return e - t
        }), t = Math.floor(r / 2), console.log(e), {
            max: e[r - 1],
            med: r % 2 ? e[t] : (e[t - 1] + e[t]) / 2
        }
    }
    var n = el("[data-type=metrics]"),
        i = el("[data-type=metrics] > div");
    if (i.innerHTML = "", !prefs.meta.complex || !e.length) return n.style.display = "none", !1;
    if (n.style.display = "block", 1 === e.length) {
        switch (t("There is only <b>one</b> function in this file."), e[0].metrics.parameters) {
        case 0:
            t("It takes <b>no</b> arguments.");
            break;
        case 1:
            t("It takes <b>one</b> argument.");
            break;
        default:
            t("It takes <b>" + e[0].metrics.parameters + "</b> arguments.")
        }
        switch (e[0].metrics.statements) {
        case 0:
            t("This function is <b>empty</b>.");
            break;
        case 1:
            t("This function contains only <b>one</b> statement.");
            break;
        default:
            t("This function contains <b>" + e[0].metrics.statements + "</b> statements.")
        }
        return t("Cyclomatic complexity number for this function is <b>" + e[0].metrics.complexity + "</b>."), void 0
    }
    var o = e.length,
        l = r(e.map(function (e) {
            return e.metrics.parameters
        })),
        s = r(e.map(function (e) {
            return e.metrics.statements
        })),
        a = r(e.map(function (e) {
            return e.metrics.complexity
        }));
    t("There are <b>" + o + "</b> functions in this file."), t("Function with the largest signature take <b>" + l.max + "</b> arguments, while the median is <b>" + l.med + "</b>."), t("Largest function has <b>" + s.max + "</b> statements in it," + " while the median is <b>" + s.med + "</b>."), t("The most complex function has a cyclomatic complexity value of <b>" + a.max + "</b> while the median is <b>" + a.med + "</b>.")
}
window.CodeMirror = function () {
    "use strict";

    function e(r, n) {
        if (!(this instanceof e)) return new e(r, n);
        this.options = n = n || {};
        for (var i in no)!n.hasOwnProperty(i) && no.hasOwnProperty(i) && (n[i] = no[i]);
        h(n);
        var o = "string" == typeof n.value ? 0 : n.value.first,
            l = this.display = t(r, o);
        l.wrapper.CodeMirror = this, u(this), n.autofocus && !Pi && dt(this), this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: !1,
            focused: !1,
            suppressEdits: !1,
            pasteIncoming: !1,
            draggingText: !1,
            highlight: new Kn
        }, s(this), n.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap");
        var a = n.value;
        "string" == typeof a && (a = new yo(n.value, n.mode)), ot(this, cn)(this, a), ki && setTimeout(ei(ht, this, !0), 20), mt(this);
        var c;
        try {
            c = document.activeElement == l.input
        } catch (f) {}
        c || n.autofocus && !Pi ? setTimeout(ei(Wt, this), 20) : Et(this), ot(this, function () {
            for (var e in ro) ro.propertyIsEnumerable(e) && ro[e](this, n[e], io);
            for (var t = 0; t < ao.length; ++t) ao[t](this)
        })()
    }

    function t(e, t) {
        var r = {}, n = r.input = ni("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
        return Ti ? n.style.width = "1000px" : n.setAttribute("wrap", "off"), zi && (n.style.border = "1px solid black"), n.setAttribute("autocorrect", "off"), n.setAttribute("autocapitalize", "off"), n.setAttribute("spellcheck", "false"), r.inputDiv = ni("div", [n], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"), r.scrollbarH = ni("div", [ni("div", null, null, "height: 1px")], "CodeMirror-hscrollbar"), r.scrollbarV = ni("div", [ni("div", null, null, "width: 1px")], "CodeMirror-vscrollbar"), r.scrollbarFiller = ni("div", null, "CodeMirror-scrollbar-filler"), r.gutterFiller = ni("div", null, "CodeMirror-gutter-filler"), r.lineDiv = ni("div", null, "CodeMirror-code"), r.selectionDiv = ni("div", null, null, "position: relative; z-index: 1"), r.cursor = ni("div", "\xa0", "CodeMirror-cursor"), r.otherCursor = ni("div", "\xa0", "CodeMirror-cursor CodeMirror-secondarycursor"), r.measure = ni("div", null, "CodeMirror-measure"), r.lineSpace = ni("div", [r.measure, r.selectionDiv, r.lineDiv, r.cursor, r.otherCursor], null, "position: relative; outline: none"), r.mover = ni("div", [ni("div", [r.lineSpace], "CodeMirror-lines")], null, "position: relative"), r.sizer = ni("div", [r.mover], "CodeMirror-sizer"), r.heightForcer = ni("div", null, null, "position: absolute; height: " + Lo + "px; width: 1px;"), r.gutters = ni("div", null, "CodeMirror-gutters"), r.lineGutter = null, r.scroller = ni("div", [r.sizer, r.heightForcer, r.gutters], "CodeMirror-scroll"), r.scroller.setAttribute("tabIndex", "-1"), r.wrapper = ni("div", [r.inputDiv, r.scrollbarH, r.scrollbarV, r.scrollbarFiller, r.gutterFiller, r.scroller], "CodeMirror"), Si && (r.gutters.style.zIndex = -1, r.scroller.style.paddingRight = 0), e.appendChild ? e.appendChild(r.wrapper) : e(r.wrapper), zi && (n.style.width = "0px"), Ti || (r.scroller.draggable = !0), Ei ? (r.inputDiv.style.height = "1px", r.inputDiv.style.position = "absolute") : Si && (r.scrollbarH.style.minWidth = r.scrollbarV.style.minWidth = "18px"), r.viewOffset = r.lastSizeC = 0, r.showingFrom = r.showingTo = t, r.lineNumWidth = r.lineNumInnerWidth = r.lineNumChars = null, r.prevInput = "", r.alignWidgets = !1, r.pollingFast = !1, r.poll = new Kn, r.cachedCharWidth = r.cachedTextHeight = null, r.measureLineCache = [], r.measureLineCachePos = 0, r.inaccurateSelection = !1, r.maxLine = null, r.maxLineLength = 0, r.maxLineChanged = !1, r.wheelDX = r.wheelDY = r.wheelStartX = r.wheelStartY = null, r
    }

    function r(t) {
        t.doc.mode = e.getMode(t.options, t.doc.modeOption), t.doc.iter(function (e) {
            e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null)
        }), t.doc.frontier = t.doc.first, E(t, 100), t.state.modeGen++, t.curOp && at(t)
    }

    function n(e) {
        e.options.lineWrapping ? (e.display.wrapper.className += " CodeMirror-wrap", e.display.sizer.style.minWidth = "") : (e.display.wrapper.className = e.display.wrapper.className.replace(" CodeMirror-wrap", ""), f(e)), o(e), at(e), K(e), setTimeout(function () {
            d(e)
        }, 100)
    }

    function i(e) {
        var t = tt(e.display),
            r = e.options.lineWrapping,
            n = r && Math.max(5, e.display.scroller.clientWidth / rt(e.display) - 3);
        return function (i) {
            return Rr(e.doc, i) ? 0 : r ? (Math.ceil(i.text.length / n) || 1) * t : t
        }
    }

    function o(e) {
        var t = e.doc,
            r = i(e);
        t.iter(function (e) {
            var t = r(e);
            t != e.height && pn(e, t)
        })
    }

    function l(e) {
        var t = fo[e.options.keyMap],
            r = t.style;
        e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") + (r ? " cm-keymap-" + r : ""), e.state.disableInput = t.disableInput
    }

    function s(e) {
        e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), K(e)
    }

    function a(e) {
        u(e), at(e), setTimeout(function () {
            m(e)
        }, 20)
    }

    function u(e) {
        var t = e.display.gutters,
            r = e.options.gutters;
        ii(t);
        for (var n = 0; n < r.length; ++n) {
            var i = r[n],
                o = t.appendChild(ni("div", null, "CodeMirror-gutter " + i));
            "CodeMirror-linenumbers" == i && (e.display.lineGutter = o, o.style.width = (e.display.lineNumWidth || 1) + "px")
        }
        t.style.display = n ? "" : "none"
    }

    function c(e, t) {
        if (0 == t.height) return 0;
        for (var r, n = t.text.length, i = t; r = zr(i);) {
            var o = r.find();
            i = fn(e, o.from.line), n += o.from.ch - o.to.ch
        }
        for (i = t; r = Pr(i);) {
            var o = r.find();
            n -= i.text.length - o.from.ch, i = fn(e, o.to.line), n += i.text.length - o.to.ch
        }
        return n
    }

    function f(e) {
        var t = e.display,
            r = e.doc;
        t.maxLine = fn(r, r.first), t.maxLineLength = c(r, t.maxLine), t.maxLineChanged = !0, r.iter(function (e) {
            var n = c(r, e);
            n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = e)
        })
    }

    function h(e) {
        for (var t = !1, r = 0; r < e.gutters.length; ++r) "CodeMirror-linenumbers" == e.gutters[r] && (e.lineNumbers ? t = !0 : e.gutters.splice(r--, 1));
        !t && e.lineNumbers && e.gutters.push("CodeMirror-linenumbers")
    }

    function d(e) {
        var t = e.display,
            r = e.doc.height,
            n = r + P(t);
        t.sizer.style.minHeight = t.heightForcer.style.top = n + "px", t.gutters.style.height = Math.max(n, t.scroller.clientHeight - Lo) + "px";
        var i = Math.max(n, t.scroller.scrollHeight),
            o = t.scroller.scrollWidth > t.scroller.clientWidth + 1,
            l = i > t.scroller.clientHeight + 1;
        l ? (t.scrollbarV.style.display = "block", t.scrollbarV.style.bottom = o ? ui(t.measure) + "px" : "0", t.scrollbarV.firstChild.style.height = i - t.scroller.clientHeight + t.scrollbarV.clientHeight + "px") : t.scrollbarV.style.display = "", o ? (t.scrollbarH.style.display = "block", t.scrollbarH.style.right = l ? ui(t.measure) + "px" : "0", t.scrollbarH.firstChild.style.width = t.scroller.scrollWidth - t.scroller.clientWidth + t.scrollbarH.clientWidth + "px") : t.scrollbarH.style.display = "", o && l ? (t.scrollbarFiller.style.display = "block", t.scrollbarFiller.style.height = t.scrollbarFiller.style.width = ui(t.measure) + "px") : t.scrollbarFiller.style.display = "", o && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (t.gutterFiller.style.display = "block", t.gutterFiller.style.height = ui(t.measure) + "px", t.gutterFiller.style.width = t.gutters.offsetWidth + "px") : t.gutterFiller.style.display = "", Di && 0 === ui(t.measure) && (t.scrollbarV.style.minWidth = t.scrollbarH.style.minHeight = Oi ? "18px" : "12px")
    }

    function p(e, t, r) {
        var n = e.scroller.scrollTop,
            i = e.wrapper.clientHeight;
        "number" == typeof r ? n = r : r && (n = r.top, i = r.bottom - r.top), n = Math.floor(n - z(e));
        var o = Math.ceil(n + i);
        return {
            from: gn(t, n),
            to: gn(t, o)
        }
    }

    function m(e) {
        var t = e.display;
        if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) {
            for (var r = y(t) - t.scroller.scrollLeft + e.doc.scrollLeft, n = t.gutters.offsetWidth, i = r + "px", o = t.lineDiv.firstChild; o; o = o.nextSibling)
                if (o.alignable)
                    for (var l = 0, s = o.alignable; l < s.length; ++l) s[l].style.left = i;
            e.options.fixedGutter && (t.gutters.style.left = r + n + "px")
        }
    }

    function g(e) {
        if (!e.options.lineNumbers) return !1;
        var t = e.doc,
            r = v(e.options, t.first + t.size - 1),
            n = e.display;
        if (r.length != n.lineNumChars) {
            var i = n.measure.appendChild(ni("div", [ni("div", r)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                o = i.firstChild.offsetWidth,
                l = i.offsetWidth - o;
            return n.lineGutter.style.width = "", n.lineNumInnerWidth = Math.max(o, n.lineGutter.offsetWidth - l), n.lineNumWidth = n.lineNumInnerWidth + l, n.lineNumChars = n.lineNumInnerWidth ? r.length : -1, n.lineGutter.style.width = n.lineNumWidth + "px", !0
        }
        return !1
    }

    function v(e, t) {
        return String(e.lineNumberFormatter(t + e.firstLineNumber))
    }

    function y(e) {
        return si(e.scroller).left - si(e.sizer).left
    }

    function b(e, t, r, n) {
        for (var i, o = e.display.showingFrom, l = e.display.showingTo, s = p(e.display, e.doc, r); x(e, t, s, n) && (n = !1, i = !0, A(e), d(e), r && (r = Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, "number" == typeof r ? r : r.top)), s = p(e.display, e.doc, r), !(s.from >= e.display.showingFrom && s.to <= e.display.showingTo));) t = [];
        return i && (Vn(e, "update", e), (e.display.showingFrom != o || e.display.showingTo != l) && Vn(e, "viewportChange", e, e.display.showingFrom, e.display.showingTo)), i
    }

    function x(e, t, r, n) {
        var i = e.display,
            o = e.doc;
        if (!i.wrapper.clientWidth) return i.showingFrom = i.showingTo = o.first, i.viewOffset = 0, void 0;
        if (!(!n && 0 == t.length && r.from > i.showingFrom && r.to < i.showingTo)) {
            g(e) && (t = [{
                from: o.first,
                to: o.first + o.size
            }]);
            var l = i.sizer.style.marginLeft = i.gutters.offsetWidth + "px";
            i.scrollbarH.style.left = e.options.fixedGutter ? l : "0";
            var s = 1 / 0;
            if (e.options.lineNumbers)
                for (var a = 0; a < t.length; ++a)
                    if (t[a].diff) {
                        s = t[a].from;
                        break
                    }
            var u = o.first + o.size,
                c = Math.max(r.from - e.options.viewportMargin, o.first),
                f = Math.min(u, r.to + e.options.viewportMargin);
            if (i.showingFrom < c && c - i.showingFrom < 20 && (c = Math.max(o.first, i.showingFrom)), i.showingTo > f && i.showingTo - f < 20 && (f = Math.min(u, i.showingTo)), Xi)
                for (c = mn(Fr(o, fn(o, c))); u > f && Rr(o, fn(o, f));)++f;
            var h = [{
                from: Math.max(i.showingFrom, o.first),
                to: Math.min(i.showingTo, u)
            }];
            if (h = h[0].from >= h[0].to ? [] : L(h, t), Xi)
                for (var a = 0; a < h.length; ++a)
                    for (var d, p = h[a]; d = Pr(fn(o, p.to - 1));) {
                        var m = d.find().from.line;
                        if (!(m > p.from)) {
                            h.splice(a--, 1);
                            break
                        }
                        p.to = m
                    }
            for (var v = 0, a = 0; a < h.length; ++a) {
                var p = h[a];
                p.from < c && (p.from = c), p.to > f && (p.to = f), p.from >= p.to ? h.splice(a--, 1) : v += p.to - p.from
            }
            if (!n && v == f - c && c == i.showingFrom && f == i.showingTo) return C(e), void 0;
            h.sort(function (e, t) {
                return e.from - t.from
            });
            try {
                var y = document.activeElement
            } catch (b) {}.7 * (f - c) > v && (i.lineDiv.style.display = "none"), S(e, c, f, h, s), i.lineDiv.style.display = "", y && document.activeElement != y && y.offsetHeight && y.focus();
            var x = c != i.showingFrom || f != i.showingTo || i.lastSizeC != i.wrapper.clientHeight;
            return x && (i.lastSizeC = i.wrapper.clientHeight, E(e, 400)), i.showingFrom = c, i.showingTo = f, w(e), C(e), !0
        }
    }

    function w(e) {
        for (var t, r = e.display, n = r.lineDiv.offsetTop, i = r.lineDiv.firstChild; i; i = i.nextSibling)
            if (i.lineObj) {
                if (Si) {
                    var o = i.offsetTop + i.offsetHeight;
                    t = o - n, n = o
                } else {
                    var l = si(i);
                    t = l.bottom - l.top
                }
                var s = i.lineObj.height - t;
                if (2 > t && (t = tt(r)), s > .001 || -.001 > s) {
                    pn(i.lineObj, t);
                    var a = i.lineObj.widgets;
                    if (a)
                        for (var u = 0; u < a.length; ++u) a[u].height = a[u].node.offsetHeight
                }
            }
    }

    function C(e) {
        var t = e.display.viewOffset = vn(e, fn(e.doc, e.display.showingFrom));
        e.display.mover.style.top = t + "px"
    }

    function L(e, t) {
        for (var r = 0, n = t.length || 0; n > r; ++r) {
            for (var i = t[r], o = [], l = i.diff || 0, s = 0, a = e.length; a > s; ++s) {
                var u = e[s];
                i.to <= u.from && i.diff ? o.push({
                    from: u.from + l,
                    to: u.to + l
                }) : i.to <= u.from || i.from >= u.to ? o.push(u) : (i.from > u.from && o.push({
                    from: u.from,
                    to: i.from
                }), i.to < u.to && o.push({
                    from: i.to + l,
                    to: u.to + l
                }))
            }
            e = o
        }
        return e
    }

    function k(e) {
        for (var t = e.display, r = {}, n = {}, i = t.gutters.firstChild, o = 0; i; i = i.nextSibling, ++o) r[e.options.gutters[o]] = i.offsetLeft, n[e.options.gutters[o]] = i.offsetWidth;
        return {
            fixedPos: y(t),
            gutterTotalWidth: t.gutters.offsetWidth,
            gutterLeft: r,
            gutterWidth: n,
            wrapperWidth: t.wrapper.clientWidth
        }
    }

    function S(e, t, r, n, i) {
        function o(t) {
            var r = t.nextSibling;
            return Ti && Fi && e.display.currentWheelTarget == t ? (t.style.display = "none", t.lineObj = null) : t.parentNode.removeChild(t), r
        }
        var l = k(e),
            s = e.display,
            a = e.options.lineNumbers;
        n.length || Ti && e.display.currentWheelTarget || ii(s.lineDiv);
        var u = s.lineDiv,
            c = u.firstChild,
            f = n.shift(),
            h = t;
        for (e.doc.iter(t, r, function (t) {
            if (f && f.to == h && (f = n.shift()), Rr(e.doc, t)) {
                if (0 != t.height && pn(t, 0), t.widgets && c.previousSibling)
                    for (var r = 0; r < t.widgets.length; ++r) {
                        var s = t.widgets[r];
                        if (s.showIfHidden) {
                            var d = c.previousSibling;
                            if (/pre/i.test(d.nodeName)) {
                                var p = ni("div", null, null, "position: relative");
                                d.parentNode.replaceChild(p, d), p.appendChild(d), d = p
                            }
                            var m = d.appendChild(ni("div", [s.node], "CodeMirror-linewidget"));
                            s.handleMouseEvents || (m.ignoreEvents = !0), T(s, m, d, l)
                        }
                    }
            } else if (f && f.from <= h && f.to > h) {
                for (; c.lineObj != t;) c = o(c);
                a && h >= i && c.lineNumber && li(c.lineNumber, v(e.options, h)), c = c.nextSibling
            } else {
                if (t.widgets)
                    for (var g, y = 0, b = c; b && 20 > y; ++y, b = b.nextSibling)
                        if (b.lineObj == t && /div/i.test(b.nodeName)) {
                            g = b;
                            break
                        }
                var x = M(e, t, h, l, g);
                if (x != g) u.insertBefore(x, c);
                else {
                    for (; c != g;) c = o(c);
                    c = c.nextSibling
                }
                x.lineObj = t
            }++h
        }); c;) c = o(c)
    }

    function M(e, t, r, n, i) {
        var o, l = Qr(e, t),
            s = t.gutterMarkers,
            a = e.display;
        if (!(e.options.lineNumbers || s || t.bgClass || t.wrapClass || t.widgets)) return l;
        if (i) {
            i.alignable = null;
            for (var u, c = !0, f = 0, h = null, d = i.firstChild; d; d = u)
                if (u = d.nextSibling, /\bCodeMirror-linewidget\b/.test(d.className)) {
                    for (var p = 0; p < t.widgets.length; ++p) {
                        var m = t.widgets[p];
                        if (m.node == d.firstChild) {
                            m.above || h || (h = d), T(m, d, i, n), ++f;
                            break
                        }
                    }
                    if (p == t.widgets.length) {
                        c = !1;
                        break
                    }
                } else i.removeChild(d);
            i.insertBefore(l, h), c && f == t.widgets.length && (o = i, i.className = t.wrapClass || "")
        }
        if (o || (o = ni("div", null, t.wrapClass, "position: relative"), o.appendChild(l)), t.bgClass && o.insertBefore(ni("div", null, t.bgClass + " CodeMirror-linebackground"), o.firstChild), e.options.lineNumbers || s) {
            var g = o.insertBefore(ni("div", null, null, "position: absolute; left: " + (e.options.fixedGutter ? n.fixedPos : -n.gutterTotalWidth) + "px"), o.firstChild);
            if (e.options.fixedGutter && (o.alignable || (o.alignable = [])).push(g), !e.options.lineNumbers || s && s["CodeMirror-linenumbers"] || (o.lineNumber = g.appendChild(ni("div", v(e.options, r), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + n.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + a.lineNumInnerWidth + "px"))), s)
                for (var y = 0; y < e.options.gutters.length; ++y) {
                    var b = e.options.gutters[y],
                        x = s.hasOwnProperty(b) && s[b];
                    x && g.appendChild(ni("div", [x], "CodeMirror-gutter-elt", "left: " + n.gutterLeft[b] + "px; width: " + n.gutterWidth[b] + "px"))
                }
        }
        if (Si && (o.style.zIndex = 2), t.widgets && o != i)
            for (var p = 0, w = t.widgets; p < w.length; ++p) {
                var m = w[p],
                    C = ni("div", [m.node], "CodeMirror-linewidget");
                m.handleMouseEvents || (C.ignoreEvents = !0), T(m, C, o, n), m.above ? o.insertBefore(C, e.options.lineNumbers && 0 != t.height ? g : l) : o.appendChild(C), Vn(m, "redraw")
            }
        return o
    }

    function T(e, t, r, n) {
        if (e.noHScroll) {
            (r.alignable || (r.alignable = [])).push(t);
            var i = n.wrapperWidth;
            t.style.left = n.fixedPos + "px", e.coverGutter || (i -= n.gutterTotalWidth, t.style.paddingLeft = n.gutterTotalWidth + "px"), t.style.width = i + "px"
        }
        e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -n.gutterTotalWidth + "px"))
    }

    function A(e) {
        var t = e.display,
            r = Kt(e.doc.sel.from, e.doc.sel.to);
        if (r || e.options.showCursorWhenSelecting ? N(e) : t.cursor.style.display = t.otherCursor.style.display = "none", r ? t.selectionDiv.style.display = "none" : H(e), e.options.moveInputWithCursor) {
            var n = Z(e, e.doc.sel.head, "div"),
                i = si(t.wrapper),
                o = si(t.lineDiv);
            t.inputDiv.style.top = Math.max(0, Math.min(t.wrapper.clientHeight - 10, n.top + o.top - i.top)) + "px", t.inputDiv.style.left = Math.max(0, Math.min(t.wrapper.clientWidth - 10, n.left + o.left - i.left)) + "px"
        }
    }

    function N(e) {
        var t = e.display,
            r = Z(e, e.doc.sel.head, "div");
        t.cursor.style.left = r.left + "px", t.cursor.style.top = r.top + "px", t.cursor.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", t.cursor.style.display = "", r.other ? (t.otherCursor.style.display = "", t.otherCursor.style.left = r.other.left + "px", t.otherCursor.style.top = r.other.top + "px", t.otherCursor.style.height = .85 * (r.other.bottom - r.other.top) + "px") : t.otherCursor.style.display = "none"
    }

    function H(e) {
        function t(e, t, r, n) {
            0 > t && (t = 0), l.appendChild(ni("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px; top: " + t + "px; width: " + (null == r ? s - e : r) + "px; height: " + (n - t) + "px"))
        }

        function r(r, n, o) {
            function l(t, n) {
                return q(e, Ut(r, t), "div", f, n)
            }
            var u, c, f = fn(i, r),
                h = f.text.length;
            return fi(yn(f), n || 0, null == o ? h : o, function (e, r, i) {
                var f, d, p, m = l(e, "left");
                if (e == r) f = m, d = p = m.left;
                else {
                    if (f = l(r - 1, "right"), "rtl" == i) {
                        var g = m;
                        m = f, f = g
                    }
                    d = m.left, p = f.right
                }
                null == n && 0 == e && (d = a), f.top - m.top > 3 && (t(d, m.top, null, m.bottom), d = a, m.bottom < f.top && t(d, m.bottom, null, f.top)), null == o && r == h && (p = s), (!u || m.top < u.top || m.top == u.top && m.left < u.left) && (u = m), (!c || f.bottom > c.bottom || f.bottom == c.bottom && f.right > c.right) && (c = f), a + 1 > d && (d = a), t(d, f.top, p - d, f.bottom)
            }), {
                start: u,
                end: c
            }
        }
        var n = e.display,
            i = e.doc,
            o = e.doc.sel,
            l = document.createDocumentFragment(),
            s = n.lineSpace.offsetWidth,
            a = F(e.display);
        if (o.from.line == o.to.line) r(o.from.line, o.from.ch, o.to.ch);
        else {
            var u = fn(i, o.from.line),
                c = fn(i, o.to.line),
                f = Fr(i, u) == Fr(i, c),
                h = r(o.from.line, o.from.ch, f ? u.text.length : null).end,
                d = r(o.to.line, f ? 0 : null, o.to.ch).start;
            f && (h.top < d.top - 2 ? (t(h.right, h.top, null, h.bottom), t(a, d.top, d.left, d.bottom)) : t(h.right, h.top, d.left - h.right, h.bottom)), h.bottom < d.top && t(a, h.bottom, null, d.top)
        }
        oi(n.selectionDiv, l), n.selectionDiv.style.display = ""
    }

    function W(e) {
        if (e.state.focused) {
            var t = e.display;
            clearInterval(t.blinker);
            var r = !0;
            t.cursor.style.visibility = t.otherCursor.style.visibility = "", t.blinker = setInterval(function () {
                t.cursor.style.visibility = t.otherCursor.style.visibility = (r = !r) ? "" : "hidden"
            }, e.options.cursorBlinkRate)
        }
    }

    function E(e, t) {
        e.doc.mode.startState && e.doc.frontier < e.display.showingTo && e.state.highlight.set(t, ei(D, e))
    }

    function D(e) {
        var t = e.doc;
        if (t.frontier < t.first && (t.frontier = t.first), !(t.frontier >= e.display.showingTo)) {
            var r, n = +new Date + e.options.workTime,
                i = gr(t.mode, I(e, t.frontier)),
                o = [];
            t.iter(t.frontier, Math.min(t.first + t.size, e.display.showingTo + 500), function (l) {
                if (t.frontier >= e.display.showingFrom) {
                    var s = l.styles;
                    l.styles = $r(e, l, i);
                    for (var a = !s || s.length != l.styles.length, u = 0; !a && u < s.length; ++u) a = s[u] != l.styles[u];
                    a && (r && r.end == t.frontier ? r.end++ : o.push(r = {
                        start: t.frontier,
                        end: t.frontier + 1
                    })), l.stateAfter = gr(t.mode, i)
                } else Zr(e, l, i), l.stateAfter = 0 == t.frontier % 5 ? gr(t.mode, i) : null;
                return ++t.frontier, +new Date > n ? (E(e, e.options.workDelay), !0) : void 0
            }), o.length && ot(e, function () {
                for (var e = 0; e < o.length; ++e) at(this, o[e].start, o[e].end)
            })()
        }
    }

    function O(e, t, r) {
        for (var n, i, o = e.doc, l = t, s = t - 100; l > s; --l) {
            if (l <= o.first) return o.first;
            var a = fn(o, l - 1);
            if (a.stateAfter && (!r || l <= o.frontier)) return l;
            var u = _n(a.text, null, e.options.tabSize);
            (null == i || n > u) && (i = l - 1, n = u)
        }
        return i
    }

    function I(e, t, r) {
        var n = e.doc,
            i = e.display;
        if (!n.mode.startState) return !0;
        var o = O(e, t, r),
            l = o > n.first && fn(n, o - 1).stateAfter;
        return l = l ? gr(n.mode, l) : vr(n.mode), n.iter(o, t, function (r) {
            Zr(e, r, l);
            var s = o == t - 1 || 0 == o % 5 || o >= i.showingFrom && o < i.showingTo;
            r.stateAfter = s ? gr(n.mode, l) : null, ++o
        }), l
    }

    function z(e) {
        return e.lineSpace.offsetTop
    }

    function P(e) {
        return e.mover.offsetHeight - e.lineSpace.offsetHeight
    }

    function F(e) {
        var t = oi(e.measure, ni("pre", null, null, "text-align: left")).appendChild(ni("span", "x"));
        return t.offsetLeft
    }

    function R(e, t, r, n, i) {
        var o = -1;
        n = n || B(e, t);
        for (var l = r;; l += o) {
            var s = n[l];
            if (s) break;
            0 > o && 0 == l && (o = 1)
        }
        return i = l > r ? "left" : r > l ? "right" : i, "left" == i && s.leftSide ? s = s.leftSide : "right" == i && s.rightSide && (s = s.rightSide), {
            left: r > l ? s.right : s.left,
            right: l > r ? s.left : s.right,
            top: s.top,
            bottom: s.bottom
        }
    }

    function V(e, t) {
        for (var r = e.display.measureLineCache, n = 0; n < r.length; ++n) {
            var i = r[n];
            if (i.text == t.text && i.markedSpans == t.markedSpans && e.display.scroller.clientWidth == i.width && i.classes == t.textClass + "|" + t.bgClass + "|" + t.wrapClass) return i
        }
    }

    function G(e, t) {
        var r = V(e, t);
        r && (r.text = r.measure = r.markedSpans = null)
    }

    function B(e, t) {
        var r = V(e, t);
        if (r) return r.measure;
        var n = j(e, t),
            i = e.display.measureLineCache,
            o = {
                text: t.text,
                width: e.display.scroller.clientWidth,
                markedSpans: t.markedSpans,
                measure: n,
                classes: t.textClass + "|" + t.bgClass + "|" + t.wrapClass
            };
        return 16 == i.length ? i[++e.display.measureLineCachePos % 16] = o : i.push(o), n
    }

    function j(e, t) {
        function r(e) {
            var t = e.top - p.top,
                r = e.bottom - p.top;
            r > v && (r = v), 0 > t && (t = 0);
            for (var n = m.length - 2; n >= 0; n -= 2) {
                var i = m[n],
                    o = m[n + 1];
                if (!(i > r || t > o) && (t >= i && o >= r || i >= t && r >= o || Math.min(r, o) - Math.max(t, i) >= r - t >> 1)) {
                    m[n] = Math.min(t, i), m[n + 1] = Math.max(r, o);
                    break
                }
            }
            return 0 > n && (n = m.length, m.push(t, r)), {
                left: e.left - p.left,
                right: e.right - p.left,
                top: n,
                bottom: null
            }
        }

        function n(e) {
            e.bottom = m[e.top + 1], e.top = m[e.top]
        }
        var i = e.display,
            o = Qn(t.text.length),
            l = Qr(e, t, o, !0);
        if (ki && !Si && !e.options.lineWrapping && l.childNodes.length > 100) {
            for (var s = document.createDocumentFragment(), a = 10, u = l.childNodes.length, c = 0, f = Math.ceil(u / a); f > c; ++c) {
                for (var h = ni("div", null, null, "display: inline-block"), d = 0; a > d && u; ++d) h.appendChild(l.firstChild), --u;
                s.appendChild(h)
            }
            l.appendChild(s)
        }
        oi(i.measure, l);
        var p = si(i.lineDiv),
            m = [],
            g = Qn(t.text.length),
            v = l.offsetHeight;
        Mi && i.measure.first != l && oi(i.measure, l);
        for (var y, c = 0; c < o.length; ++c)
            if (y = o[c]) {
                var b = y,
                    x = null;
                if (/\bCodeMirror-widget\b/.test(y.className) && y.getClientRects) {
                    1 == y.firstChild.nodeType && (b = y.firstChild);
                    var w = b.getClientRects();
                    w.length > 1 && (x = g[c] = r(w[0]), x.rightSide = r(w[w.length - 1]))
                }
                x || (x = g[c] = r(si(b))), y.measureRight && (x.right = si(y.measureRight).left), y.leftSide && (x.leftSide = r(si(y.leftSide)))
            }
        for (var y, c = 0; c < g.length; ++c)(y = g[c]) && (n(y), y.leftSide && n(y.leftSide), y.rightSide && n(y.rightSide));
        return g
    }

    function U(e, t) {
        var r = !1;
        if (t.markedSpans)
            for (var n = 0; n < t.markedSpans; ++n) {
                var i = t.markedSpans[n];
                !i.collapsed || null != i.to && i.to != t.text.length || (r = !0)
            }
        var o = !r && V(e, t);
        if (o) return R(e, t, t.text.length, o.measure, "right").right;
        var l = Qr(e, t, null, !0),
            s = l.appendChild(ci(e.display.measure));
        return oi(e.display.measure, l), si(s).right - si(e.display.lineDiv).left
    }

    function K(e) {
        e.display.measureLineCache.length = e.display.measureLineCachePos = 0, e.display.cachedCharWidth = e.display.cachedTextHeight = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null
    }

    function _() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft
    }

    function X() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop
    }

    function Y(e, t, r, n) {
        if (t.widgets)
            for (var i = 0; i < t.widgets.length; ++i)
                if (t.widgets[i].above) {
                    var o = Ur(t.widgets[i]);
                    r.top += o, r.bottom += o
                }
        if ("line" == n) return r;
        n || (n = "local");
        var l = vn(e, t);
        if ("local" == n ? l += z(e.display) : l -= e.display.viewOffset, "page" == n || "window" == n) {
            var s = si(e.display.lineSpace);
            l += s.top + ("window" == n ? 0 : X());
            var a = s.left + ("window" == n ? 0 : _());
            r.left += a, r.right += a
        }
        return r.top += l, r.bottom += l, r
    }

    function $(e, t, r) {
        if ("div" == r) return t;
        var n = t.left,
            i = t.top;
        if ("page" == r) n -= _(), i -= X();
        else if ("local" == r || !r) {
            var o = si(e.display.sizer);
            n += o.left, i += o.top
        }
        var l = si(e.display.lineSpace);
        return {
            left: n - l.left,
            top: i - l.top
        }
    }

    function q(e, t, r, n, i) {
        return n || (n = fn(e.doc, t.line)), Y(e, n, R(e, n, t.ch, null, i), r)
    }

    function Z(e, t, r, n, i) {
        function o(t, o) {
            var l = R(e, n, t, i, o ? "right" : "left");
            return o ? l.left = l.right : l.right = l.left, Y(e, n, l, r)
        }

        function l(e, t) {
            var r = s[t],
                n = r.level % 2;
            return e == hi(r) && t && r.level < s[t - 1].level ? (r = s[--t], e = di(r) - (r.level % 2 ? 0 : 1), n = !0) : e == di(r) && t < s.length - 1 && r.level < s[t + 1].level && (r = s[++t], e = hi(r) - r.level % 2, n = !1), n && e == r.to && e > r.from ? o(e - 1) : o(e, n)
        }
        n = n || fn(e.doc, t.line), i || (i = B(e, n));
        var s = yn(n),
            a = t.ch;
        if (!s) return o(a);
        var u = bi(s, a),
            c = l(a, u);
        return null != Io && (c.other = l(a, Io)), c
    }

    function J(e, t, r, n) {
        var i = new Ut(e, t);
        return i.xRel = n, r && (i.outside = !0), i
    }

    function Q(e, t, r) {
        var n = e.doc;
        if (r += e.display.viewOffset, 0 > r) return J(n.first, 0, !0, -1);
        var i = gn(n, r),
            o = n.first + n.size - 1;
        if (i > o) return J(n.first + n.size - 1, fn(n, o).text.length, !0, 1);
        for (0 > t && (t = 0);;) {
            var l = fn(n, i),
                s = et(e, l, i, t, r),
                a = Pr(l),
                u = a && a.find();
            if (!a || !(s.ch > u.from.ch || s.ch == u.from.ch && s.xRel > 0)) return s;
            i = u.to.line
        }
    }

    function et(e, t, r, n, i) {
        function o(n) {
            var i = Z(e, Ut(r, n), "line", t, u);
            return s = !0, l > i.bottom ? i.left - a : l < i.top ? i.left + a : (s = !1, i.left)
        }
        var l = i - vn(e, t),
            s = !1,
            a = 2 * e.display.wrapper.clientWidth,
            u = B(e, t),
            c = yn(t),
            f = t.text.length,
            h = pi(t),
            d = mi(t),
            p = o(h),
            m = s,
            g = o(d),
            v = s;
        if (n > g) return J(r, d, v, 1);
        for (;;) {
            if (c ? d == h || d == wi(t, h, 1) : 1 >= d - h) {
                for (var y = p > n || g - n >= n - p ? h : d, b = n - (y == h ? p : g); To.test(t.text.charAt(y));)++y;
                var x = J(r, y, y == h ? m : v, 0 > b ? -1 : b ? 1 : 0);
                return x
            }
            var w = Math.ceil(f / 2),
                C = h + w;
            if (c) {
                C = h;
                for (var L = 0; w > L; ++L) C = wi(t, C, 1)
            }
            var k = o(C);
            k > n ? (d = C, g = k, (v = s) && (g += 1e3), f = w) : (h = C, p = k, m = s, f -= w)
        }
    }

    function tt(e) {
        if (null != e.cachedTextHeight) return e.cachedTextHeight;
        if (null == Gi) {
            Gi = ni("pre");
            for (var t = 0; 49 > t; ++t) Gi.appendChild(document.createTextNode("x")), Gi.appendChild(ni("br"));
            Gi.appendChild(document.createTextNode("x"))
        }
        oi(e.measure, Gi);
        var r = Gi.offsetHeight / 50;
        return r > 3 && (e.cachedTextHeight = r), ii(e.measure), r || 1
    }

    function rt(e) {
        if (null != e.cachedCharWidth) return e.cachedCharWidth;
        var t = ni("span", "x"),
            r = ni("pre", [t]);
        oi(e.measure, r);
        var n = t.offsetWidth;
        return n > 2 && (e.cachedCharWidth = n), n || 10
    }

    function nt(e) {
        e.curOp = {
            changes: [],
            forceUpdate: !1,
            updateInput: null,
            userSelChange: null,
            textChanged: null,
            selectionChanged: !1,
            cursorActivity: !1,
            updateMaxLine: !1,
            updateScrollPos: !1,
            id: ++Yi
        }, Co++ || (wo = [])
    }

    function it(e) {
        var t = e.curOp,
            r = e.doc,
            n = e.display;
        if (e.curOp = null, t.updateMaxLine && f(e), n.maxLineChanged && !e.options.lineWrapping && n.maxLine) {
            var i = U(e, n.maxLine);
            n.sizer.style.minWidth = Math.max(0, i + 3 + Lo) + "px", n.maxLineChanged = !1;
            var o = Math.max(0, n.sizer.offsetLeft + n.sizer.offsetWidth - n.scroller.clientWidth);
            o < r.scrollLeft && !t.updateScrollPos && Lt(e, Math.min(n.scroller.scrollLeft, o), !0)
        }
        var l, s;
        if (t.updateScrollPos) l = t.updateScrollPos;
        else if (t.selectionChanged && n.scroller.clientHeight) {
            var a = Z(e, r.sel.head);
            l = lr(e, a.left, a.top, a.left, a.bottom)
        }(t.changes.length || t.forceUpdate || l && null != l.scrollTop) && (s = b(e, t.changes, l && l.scrollTop, t.forceUpdate), e.display.scroller.offsetHeight && (e.doc.scrollTop = e.display.scroller.scrollTop)), !s && t.selectionChanged && A(e), t.updateScrollPos ? (n.scroller.scrollTop = n.scrollbarV.scrollTop = r.scrollTop = l.scrollTop, n.scroller.scrollLeft = n.scrollbarH.scrollLeft = r.scrollLeft = l.scrollLeft, m(e), t.scrollToPos && ir(e, $t(e.doc, t.scrollToPos), t.scrollToPosMargin)) : l && nr(e), t.selectionChanged && W(e), e.state.focused && t.updateInput && ht(e, t.userSelChange);
        var u = t.maybeHiddenMarkers,
            c = t.maybeUnhiddenMarkers;
        if (u)
            for (var h = 0; h < u.length; ++h) u[h].lines.length || Rn(u[h], "hide");
        if (c)
            for (var h = 0; h < c.length; ++h) c[h].lines.length && Rn(c[h], "unhide");
        var d;
        if (--Co || (d = wo, wo = null), t.textChanged && Rn(e, "change", e, t.textChanged), t.cursorActivity && Rn(e, "cursorActivity", e), d)
            for (var h = 0; h < d.length; ++h) d[h]()
    }

    function ot(e, t) {
        return function () {
            var r = e || this,
                n = !r.curOp;
            n && nt(r);
            try {
                var i = t.apply(r, arguments)
            } finally {
                n && it(r)
            }
            return i
        }
    }

    function lt(e) {
        return function () {
            var t, r = this.cm && !this.cm.curOp;
            r && nt(this.cm);
            try {
                t = e.apply(this, arguments)
            } finally {
                r && it(this.cm)
            }
            return t
        }
    }

    function st(e, t) {
        var r, n = !e.curOp;
        n && nt(e);
        try {
            r = t()
        } finally {
            n && it(e)
        }
        return r
    }

    function at(e, t, r, n) {
        null == t && (t = e.doc.first), null == r && (r = e.doc.first + e.doc.size), e.curOp.changes.push({
            from: t,
            to: r,
            diff: n
        })
    }

    function ut(e) {
        e.display.pollingFast || e.display.poll.set(e.options.pollInterval, function () {
            ft(e), e.state.focused && ut(e)
        })
    }

    function ct(e) {
        function t() {
            var n = ft(e);
            n || r ? (e.display.pollingFast = !1, ut(e)) : (r = !0, e.display.poll.set(60, t))
        }
        var r = !1;
        e.display.pollingFast = !0, e.display.poll.set(20, t)
    }

    function ft(e) {
        var t = e.display.input,
            r = e.display.prevInput,
            n = e.doc,
            i = n.sel;
        if (!e.state.focused || Eo(t) || pt(e) || e.state.disableInput) return !1;
        var o = t.value;
        if (o == r && Kt(i.from, i.to)) return !1;
        if (ki && !Mi && e.display.inputHasSelection === o) return ht(e, !0), !1;
        var l = !e.curOp;
        l && nt(e), i.shift = !1;
        for (var s = 0, a = Math.min(r.length, o.length); a > s && r.charCodeAt(s) == o.charCodeAt(s);)++s;
        var u = i.from,
            c = i.to;
        s < r.length ? u = Ut(u.line, u.ch - (r.length - s)) : e.state.overwrite && Kt(u, c) && !e.state.pasteIncoming && (c = Ut(c.line, Math.min(fn(n, c.line).text.length, c.ch + (o.length - s))));
        var f = e.curOp.updateInput,
            h = {
                from: u,
                to: c,
                text: Wo(o.slice(s)),
                origin: e.state.pasteIncoming ? "paste" : "+input"
            };
        return Pt(e.doc, h, "end"), e.curOp.updateInput = f, Vn(e, "inputRead", e, h), o.length > 1e3 || o.indexOf("\n") > -1 ? t.value = e.display.prevInput = "" : e.display.prevInput = o, l && it(e), e.state.pasteIncoming = !1, !0
    }

    function ht(e, t) {
        var r, n, i = e.doc;
        if (Kt(i.sel.from, i.sel.to)) t && (e.display.prevInput = e.display.input.value = "", ki && !Mi && (e.display.inputHasSelection = null));
        else {
            e.display.prevInput = "", r = Do && (i.sel.to.line - i.sel.from.line > 100 || (n = e.getSelection()).length > 1e3);
            var o = r ? "-" : n || e.getSelection();
            e.display.input.value = o, e.state.focused && $n(e.display.input), ki && !Mi && (e.display.inputHasSelection = o)
        }
        e.display.inaccurateSelection = r
    }

    function dt(e) {
        "nocursor" == e.options.readOnly || Pi && document.activeElement == e.display.input || e.display.input.focus()
    }

    function pt(e) {
        return e.options.readOnly || e.doc.cantEdit
    }

    function mt(e) {
        function t() {
            e.state.focused && setTimeout(ei(dt, e), 0)
        }

        function r() {
            null == s && (s = setTimeout(function () {
                s = null, l.cachedCharWidth = l.cachedTextHeight = No = null, K(e), st(e, ei(at, e))
            }, 100))
        }

        function n() {
            for (var e = l.wrapper.parentNode; e && e != document.body; e = e.parentNode);
            e ? setTimeout(n, 5e3) : Fn(window, "resize", r)
        }

        function i(t) {
            Gn(e, t) || e.options.onDragEvent && e.options.onDragEvent(e, Hn(t)) || On(t)
        }

        function o() {
            l.inaccurateSelection && (l.prevInput = "", l.inaccurateSelection = !1, l.input.value = e.getSelection(), $n(l.input))
        }
        var l = e.display;
        Pn(l.scroller, "mousedown", ot(e, yt)), ki ? Pn(l.scroller, "dblclick", ot(e, function (t) {
            if (!Gn(e, t)) {
                var r = vt(e, t);
                if (r && !bt(e, t) && !gt(e.display, t)) {
                    Wn(t);
                    var n = dr(fn(e.doc, r.line).text, r);
                    Jt(e.doc, n.from, n.to)
                }
            }
        })) : Pn(l.scroller, "dblclick", function (t) {
            Gn(e, t) || Wn(t)
        }), Pn(l.lineSpace, "selectstart", function (e) {
            gt(l, e) || Wn(e)
        }), Ki || Pn(l.scroller, "contextmenu", function (t) {
            Dt(e, t)
        }), Pn(l.scroller, "scroll", function () {
            l.scroller.clientHeight && (Ct(e, l.scroller.scrollTop), Lt(e, l.scroller.scrollLeft, !0), Rn(e, "scroll", e))
        }), Pn(l.scrollbarV, "scroll", function () {
            l.scroller.clientHeight && Ct(e, l.scrollbarV.scrollTop)
        }), Pn(l.scrollbarH, "scroll", function () {
            l.scroller.clientHeight && Lt(e, l.scrollbarH.scrollLeft)
        }), Pn(l.scroller, "mousewheel", function (t) {
            kt(e, t)
        }), Pn(l.scroller, "DOMMouseScroll", function (t) {
            kt(e, t)
        }), Pn(l.scrollbarH, "mousedown", t), Pn(l.scrollbarV, "mousedown", t), Pn(l.wrapper, "scroll", function () {
            l.wrapper.scrollTop = l.wrapper.scrollLeft = 0
        });
        var s;
        Pn(window, "resize", r), setTimeout(n, 5e3), Pn(l.input, "keyup", ot(e, function (t) {
            Gn(e, t) || e.options.onKeyEvent && e.options.onKeyEvent(e, Hn(t)) || 16 == t.keyCode && (e.doc.sel.shift = !1)
        })), Pn(l.input, "input", ei(ct, e)), Pn(l.input, "keydown", ot(e, Nt)), Pn(l.input, "keypress", ot(e, Ht)), Pn(l.input, "focus", ei(Wt, e)), Pn(l.input, "blur", ei(Et, e)), e.options.dragDrop && (Pn(l.scroller, "dragstart", function (t) {
            wt(e, t)
        }), Pn(l.scroller, "dragenter", i), Pn(l.scroller, "dragover", i), Pn(l.scroller, "drop", ot(e, xt))), Pn(l.scroller, "paste", function (t) {
            gt(l, t) || (dt(e), ct(e))
        }), Pn(l.input, "paste", function () {
            e.state.pasteIncoming = !0, ct(e)
        }), Pn(l.input, "cut", o), Pn(l.input, "copy", o), Ei && Pn(l.sizer, "mouseup", function () {
            document.activeElement == l.input && l.input.blur(), dt(e)
        })
    }

    function gt(e, t) {
        for (var r = In(t); r != e.wrapper; r = r.parentNode)
            if (!r || r.ignoreEvents || r.parentNode == e.sizer && r != e.mover) return !0
    }

    function vt(e, t, r) {
        var n = e.display;
        if (!r) {
            var i = In(t);
            if (i == n.scrollbarH || i == n.scrollbarH.firstChild || i == n.scrollbarV || i == n.scrollbarV.firstChild || i == n.scrollbarFiller || i == n.gutterFiller) return null
        }
        var o, l, s = si(n.lineSpace);
        try {
            o = t.clientX, l = t.clientY
        } catch (t) {
            return null
        }
        return Q(e, o - s.left, l - s.top)
    }

    function yt(e) {
        function t(e) {
            if (!Kt(v, e)) {
                if (v = e, "single" == c) return Jt(i.doc, $t(l, a), e), void 0;
                if (m = $t(l, m), g = $t(l, g), "double" == c) {
                    var t = dr(fn(l, e.line).text, e);
                    _t(e, m) ? Jt(i.doc, t.from, g) : Jt(i.doc, m, t.to)
                } else "triple" == c && (_t(e, m) ? Jt(i.doc, g, $t(l, Ut(e.line, 0))) : Jt(i.doc, m, $t(l, Ut(e.line + 1, 0))))
            }
        }

        function r(e) {
            var n = ++b,
                s = vt(i, e, !0);
            if (s)
                if (Kt(s, h)) {
                    var a = e.clientY < y.top ? -20 : e.clientY > y.bottom ? 20 : 0;
                    a && setTimeout(ot(i, function () {
                        b == n && (o.scroller.scrollTop += a, r(e))
                    }), 50)
                } else {
                    i.state.focused || Wt(i), h = s, t(s);
                    var u = p(o, l);
                    (s.line >= u.to || s.line < u.from) && setTimeout(ot(i, function () {
                        b == n && r(e)
                    }), 150)
                }
        }

        function n(e) {
            b = 1 / 0, Wn(e), dt(i), Fn(document, "mousemove", x), Fn(document, "mouseup", w)
        }
        if (!Gn(this, e)) {
            var i = this,
                o = i.display,
                l = i.doc,
                s = l.sel;
            if (s.shift = e.shiftKey, gt(o, e)) return Ti || (o.scroller.draggable = !1, setTimeout(function () {
                o.scroller.draggable = !0
            }, 100)), void 0;
            if (!bt(i, e)) {
                var a = vt(i, e);
                switch (zn(e)) {
                case 3:
                    return Ki && Dt.call(i, i, e), void 0;
                case 2:
                    return a && Jt(i.doc, a), setTimeout(ei(dt, i), 20), Wn(e), void 0
                }
                if (!a) return In(e) == o.scroller && Wn(e), void 0;
                i.state.focused || Wt(i);
                var u = +new Date,
                    c = "single";
                if (ji && ji.time > u - 400 && Kt(ji.pos, a)) c = "triple", Wn(e), setTimeout(ei(dt, i), 20), pr(i, a.line);
                else if (Bi && Bi.time > u - 400 && Kt(Bi.pos, a)) {
                    c = "double", ji = {
                        time: u,
                        pos: a
                    }, Wn(e);
                    var f = dr(fn(l, a.line).text, a);
                    Jt(i.doc, f.from, f.to)
                } else Bi = {
                    time: u,
                    pos: a
                };
                var h = a;
                if (i.options.dragDrop && Ao && !pt(i) && !Kt(s.from, s.to) && !_t(a, s.from) && !_t(s.to, a) && "single" == c) {
                    var d = ot(i, function (t) {
                        Ti && (o.scroller.draggable = !1), i.state.draggingText = !1, Fn(document, "mouseup", d), Fn(o.scroller, "drop", d), Math.abs(e.clientX - t.clientX) + Math.abs(e.clientY - t.clientY) < 10 && (Wn(t), Jt(i.doc, a), dt(i))
                    });
                    return Ti && (o.scroller.draggable = !0), i.state.draggingText = d, o.scroller.dragDrop && o.scroller.dragDrop(), Pn(document, "mouseup", d), Pn(o.scroller, "drop", d), void 0
                }
                Wn(e), "single" == c && Jt(i.doc, $t(l, a));
                var m = s.from,
                    g = s.to,
                    v = a,
                    y = si(o.wrapper),
                    b = 0,
                    x = ot(i, function (e) {
                        ki || zn(e) ? r(e) : n(e)
                    }),
                    w = ot(i, n);
                Pn(document, "mousemove", x), Pn(document, "mouseup", w)
            }
        }
    }

    function bt(e, t) {
        var r = e.display;
        try {
            var n = t.clientX,
                i = t.clientY
        } catch (t) {
            return !1
        }
        if (n >= Math.floor(si(r.gutters).right)) return !1;
        if (Wn(t), !jn(e, "gutterClick")) return !0;
        var o = si(r.lineDiv);
        if (i > o.bottom) return !0;
        i -= o.top - r.viewOffset;
        for (var l = 0; l < e.options.gutters.length; ++l) {
            var s = r.gutters.childNodes[l];
            if (s && si(s).right >= n) {
                var a = gn(e.doc, i),
                    u = e.options.gutters[l];
                Vn(e, "gutterClick", e, a, u, t);
                break
            }
        }
        return !0
    }

    function xt(e) {
        var t = this;
        if (!(Gn(t, e) || gt(t.display, e) || t.options.onDragEvent && t.options.onDragEvent(t, Hn(e)))) {
            Wn(e), ki && ($i = +new Date);
            var r = vt(t, e, !0),
                n = e.dataTransfer.files;
            if (r && !pt(t))
                if (n && n.length && window.FileReader && window.File)
                    for (var i = n.length, o = Array(i), l = 0, s = function (e, n) {
                            var s = new FileReader;
                            s.onload = function () {
                                o[n] = s.result, ++l == i && (r = $t(t.doc, r), Pt(t.doc, {
                                    from: r,
                                    to: r,
                                    text: Wo(o.join("\n")),
                                    origin: "paste"
                                }, "around"))
                            }, s.readAsText(e)
                        }, a = 0; i > a; ++a) s(n[a], a);
                else {
                    if (t.state.draggingText && !_t(r, t.doc.sel.from) && !_t(t.doc.sel.to, r)) return t.state.draggingText(e), setTimeout(ei(dt, t), 20), void 0;
                    try {
                        var o = e.dataTransfer.getData("Text");
                        if (o) {
                            var u = t.doc.sel.from,
                                c = t.doc.sel.to;
                            er(t.doc, r, r), t.state.draggingText && jt(t.doc, "", u, c, "paste"), t.replaceSelection(o, null, "paste"), dt(t), Wt(t)
                        }
                    } catch (e) {}
                }
        }
    }

    function wt(e, t) {
        if (ki && (!e.state.draggingText || +new Date - $i < 100)) return On(t), void 0;
        if (!Gn(e, t) && !gt(e.display, t)) {
            var r = e.getSelection();
            if (t.dataTransfer.setData("Text", r), t.dataTransfer.setDragImage && !Wi) {
                var n = ni("img", null, null, "position: fixed; left: 0; top: 0;");
                Hi && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), Hi && n.parentNode.removeChild(n)
            }
        }
    }

    function Ct(e, t) {
        Math.abs(e.doc.scrollTop - t) < 2 || (e.doc.scrollTop = t, Li || b(e, [], t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t), e.display.scrollbarV.scrollTop != t && (e.display.scrollbarV.scrollTop = t), Li && b(e, []), E(e, 100))
    }

    function Lt(e, t, r) {
        (r ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) || (t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth), e.doc.scrollLeft = t, m(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbarH.scrollLeft != t && (e.display.scrollbarH.scrollLeft = t))
    }

    function kt(e, t) {
        var r = t.wheelDeltaX,
            n = t.wheelDeltaY;
        null == r && t.detail && t.axis == t.HORIZONTAL_AXIS && (r = t.detail), null == n && t.detail && t.axis == t.VERTICAL_AXIS ? n = t.detail : null == n && (n = t.wheelDelta);
        var i = e.display,
            o = i.scroller;
        if (r && o.scrollWidth > o.clientWidth || n && o.scrollHeight > o.clientHeight) {
            if (n && Fi && Ti)
                for (var l = t.target; l != o; l = l.parentNode)
                    if (l.lineObj) {
                        e.display.currentWheelTarget = l;
                        break
                    }
            if (r && !Li && !Hi && null != Zi) return n && Ct(e, Math.max(0, Math.min(o.scrollTop + n * Zi, o.scrollHeight - o.clientHeight))), Lt(e, Math.max(0, Math.min(o.scrollLeft + r * Zi, o.scrollWidth - o.clientWidth))), Wn(t), i.wheelStartX = null, void 0;
            if (n && null != Zi) {
                var s = n * Zi,
                    a = e.doc.scrollTop,
                    u = a + i.wrapper.clientHeight;
                0 > s ? a = Math.max(0, a + s - 50) : u = Math.min(e.doc.height, u + s + 50), b(e, [], {
                    top: a,
                    bottom: u
                })
            }
            20 > qi && (null == i.wheelStartX ? (i.wheelStartX = o.scrollLeft, i.wheelStartY = o.scrollTop, i.wheelDX = r, i.wheelDY = n, setTimeout(function () {
                if (null != i.wheelStartX) {
                    var e = o.scrollLeft - i.wheelStartX,
                        t = o.scrollTop - i.wheelStartY,
                        r = t && i.wheelDY && t / i.wheelDY || e && i.wheelDX && e / i.wheelDX;
                    i.wheelStartX = i.wheelStartY = null, r && (Zi = (Zi * qi + r) / (qi + 1), ++qi)
                }
            }, 200)) : (i.wheelDX += r, i.wheelDY += n))
        }
    }

    function St(e, t, r) {
        if ("string" == typeof t && (t = co[t], !t)) return !1;
        e.display.pollingFast && ft(e) && (e.display.pollingFast = !1);
        var n = e.doc,
            i = n.sel.shift,
            o = !1;
        try {
            pt(e) && (e.state.suppressEdits = !0), r && (n.sel.shift = !1), o = t(e) != ko
        } finally {
            n.sel.shift = i, e.state.suppressEdits = !1
        }
        return o
    }

    function Mt(e) {
        var t = e.state.keyMaps.slice(0);
        return e.options.extraKeys && t.push(e.options.extraKeys), t.push(e.options.keyMap), t
    }

    function Tt(e, t) {
        var r = yr(e.options.keyMap),
            n = r.auto;
        clearTimeout(Ji), n && !xr(t) && (Ji = setTimeout(function () {
            yr(e.options.keyMap) == r && (e.options.keyMap = n.call ? n.call(null, e) : n, l(e))
        }, 50));
        var i = wr(t, !0),
            o = !1;
        if (!i) return !1;
        var s = Mt(e);
        return o = t.shiftKey ? br("Shift-" + i, s, function (t) {
            return St(e, t, !0)
        }) || br(i, s, function (t) {
            return ("string" == typeof t ? /^go[A-Z]/.test(t) : t.motion) ? St(e, t) : void 0
        }) : br(i, s, function (t) {
            return St(e, t)
        }), o && (Wn(t), W(e), Mi && (t.oldKeyCode = t.keyCode, t.keyCode = 0), Vn(e, "keyHandled", e, i, t)), o
    }

    function At(e, t, r) {
        var n = br("'" + r + "'", Mt(e), function (t) {
            return St(e, t, !0)
        });
        return n && (Wn(t), W(e), Vn(e, "keyHandled", e, "'" + r + "'", t)), n
    }

    function Nt(e) {
        var t = this;
        if (t.state.focused || Wt(t), ki && 27 == e.keyCode && (e.returnValue = !1), !(Gn(t, e) || t.options.onKeyEvent && t.options.onKeyEvent(t, Hn(e)))) {
            var r = e.keyCode;
            t.doc.sel.shift = 16 == r || e.shiftKey;
            var n = Tt(t, e);
            Hi && (eo = n ? r : null, !n && 88 == r && !Do && (Fi ? e.metaKey : e.ctrlKey) && t.replaceSelection(""))
        }
    }

    function Ht(e) {
        var t = this;
        if (!(Gn(t, e) || t.options.onKeyEvent && t.options.onKeyEvent(t, Hn(e)))) {
            var r = e.keyCode,
                n = e.charCode;
            if (Hi && r == eo) return eo = null, Wn(e), void 0;
            if (!(Hi && (!e.which || e.which < 10) || Ei) || !Tt(t, e)) {
                var i = String.fromCharCode(null == n ? r : n);
                this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !pt(this) && this.doc.mode.electricChars.indexOf(i) > -1 && setTimeout(ot(t, function () {
                    ur(t, t.doc.sel.to.line, "smart")
                }), 75), At(t, e, i) || (ki && !Mi && (t.display.inputHasSelection = null), ct(t))
            }
        }
    }

    function Wt(e) {
        "nocursor" != e.options.readOnly && (e.state.focused || (Rn(e, "focus", e), e.state.focused = !0, -1 == e.display.wrapper.className.search(/\bCodeMirror-focused\b/) && (e.display.wrapper.className += " CodeMirror-focused"), ht(e, !0)), ut(e), W(e))
    }

    function Et(e) {
        e.state.focused && (Rn(e, "blur", e), e.state.focused = !1, e.display.wrapper.className = e.display.wrapper.className.replace(" CodeMirror-focused", "")), clearInterval(e.display.blinker), setTimeout(function () {
            e.state.focused || (e.doc.sel.shift = !1)
        }, 150)
    }

    function Dt(e, t) {
        function r() {
            if (null != i.input.selectionStart) {
                var e = i.input.value = " " + (Kt(o.from, o.to) ? "" : i.input.value);
                i.prevInput = " ", i.input.selectionStart = 1, i.input.selectionEnd = e.length
            }
        }

        function n() {
            if (i.inputDiv.style.position = "relative", i.input.style.cssText = a, Mi && (i.scrollbarV.scrollTop = i.scroller.scrollTop = s), ut(e), null != i.input.selectionStart) {
                (!ki || Mi) && r(), clearTimeout(Qi);
                var t = 0,
                    n = function () {
                        " " == i.prevInput && 0 == i.input.selectionStart ? ot(e, co.selectAll)(e) : t++ < 10 ? Qi = setTimeout(n, 500) : ht(e)
                    };
                Qi = setTimeout(n, 200)
            }
        }
        if (!Gn(e, t, "contextmenu")) {
            var i = e.display,
                o = e.doc.sel;
            if (!gt(i, t)) {
                var l = vt(e, t),
                    s = i.scroller.scrollTop;
                if (l && !Hi) {
                    (Kt(o.from, o.to) || _t(l, o.from) || !_t(l, o.to)) && ot(e, er)(e.doc, l, l);
                    var a = i.input.style.cssText;
                    if (i.inputDiv.style.position = "absolute", i.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (t.clientY - 5) + "px; left: " + (t.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" + "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);", dt(e), ht(e, !0), Kt(o.from, o.to) && (i.input.value = i.prevInput = " "), ki && !Mi && r(), Ki) {
                        On(t);
                        var u = function () {
                            Fn(window, "mouseup", u), setTimeout(n, 20)
                        };
                        Pn(window, "mouseup", u)
                    } else setTimeout(n, 50)
                }
            }
        }
    }

    function Ot(e, t, r) {
        if (!_t(t.from, r)) return $t(e, r);
        var n = t.text.length - 1 - (t.to.line - t.from.line);
        if (r.line > t.to.line + n) {
            var i = r.line - n,
                o = e.first + e.size - 1;
            return i > o ? Ut(o, fn(e, o).text.length) : qt(r, fn(e, i).text.length)
        }
        if (r.line == t.to.line + n) return qt(r, Yn(t.text).length + (1 == t.text.length ? t.from.ch : 0) + fn(e, t.to.line).text.length - t.to.ch);
        var l = r.line - t.from.line;
        return qt(r, t.text[l].length + (l ? 0 : t.from.ch))
    }

    function It(e, t, r) {
        if (r && "object" == typeof r) return {
            anchor: Ot(e, t, r.anchor),
            head: Ot(e, t, r.head)
        };
        if ("start" == r) return {
            anchor: t.from,
            head: t.from
        };
        var n = to(t);
        if ("around" == r) return {
            anchor: t.from,
            head: n
        };
        if ("end" == r) return {
            anchor: n,
            head: n
        };
        var i = function (e) {
            if (_t(e, t.from)) return e;
            if (!_t(t.to, e)) return n;
            var r = e.line + t.text.length - (t.to.line - t.from.line) - 1,
                i = e.ch;
            return e.line == t.to.line && (i += n.ch - t.to.ch), Ut(r, i)
        };
        return {
            anchor: i(e.sel.anchor),
            head: i(e.sel.head)
        }
    }

    function zt(e, t, r) {
        var n = {
            canceled: !1,
            from: t.from,
            to: t.to,
            text: t.text,
            origin: t.origin,
            cancel: function () {
                this.canceled = !0
            }
        };
        return r && (n.update = function (t, r, n, i) {
            t && (this.from = $t(e, t)), r && (this.to = $t(e, r)), n && (this.text = n), void 0 !== i && (this.origin = i)
        }), Rn(e, "beforeChange", e, n), e.cm && Rn(e.cm, "beforeChange", e.cm, n), n.canceled ? null : {
            from: n.from,
            to: n.to,
            text: n.text,
            origin: n.origin
        }
    }

    function Pt(e, t, r, n) {
        if (e.cm) {
            if (!e.cm.curOp) return ot(e.cm, Pt)(e, t, r, n);
            if (e.cm.state.suppressEdits) return
        }
        if (!(jn(e, "beforeChange") || e.cm && jn(e.cm, "beforeChange")) || (t = zt(e, t, !0))) {
            var i = _i && !n && Or(e, t.from, t.to);
            if (i) {
                for (var o = i.length - 1; o >= 1; --o) Ft(e, {
                    from: i[o].from,
                    to: i[o].to,
                    text: [""]
                });
                i.length && Ft(e, {
                    from: i[0].from,
                    to: i[0].to,
                    text: t.text
                }, r)
            } else Ft(e, t, r)
        }
    }

    function Ft(e, t, r) {
        var n = It(e, t, r);
        Cn(e, t, n, e.cm ? e.cm.curOp.id : 0 / 0), Gt(e, t, n, Er(e, t));
        var i = [];
        un(e, function (e, r) {
            r || -1 != qn(i, e.history) || (An(e.history, t), i.push(e.history)), Gt(e, t, null, Er(e, t))
        })
    }

    function Rt(e, t) {
        if (!e.cm || !e.cm.state.suppressEdits) {
            var r = e.history,
                n = ("undo" == t ? r.done : r.undone).pop();
            if (n) {
                var i = {
                    changes: [],
                    anchorBefore: n.anchorAfter,
                    headBefore: n.headAfter,
                    anchorAfter: n.anchorBefore,
                    headAfter: n.headBefore,
                    generation: r.generation
                };
                ("undo" == t ? r.undone : r.done).push(i), r.generation = n.generation || ++r.maxGeneration;
                for (var o = jn(e, "beforeChange") || e.cm && jn(e.cm, "beforeChange"), l = n.changes.length - 1; l >= 0; --l) {
                    var s = n.changes[l];
                    if (s.origin = t, o && !zt(e, s, !1)) return ("undo" == t ? r.done : r.undone).length = 0, void 0;
                    i.changes.push(wn(e, s));
                    var a = l ? It(e, s, null) : {
                        anchor: n.anchorBefore,
                        head: n.headBefore
                    };
                    Gt(e, s, a, Dr(e, s));
                    var u = [];
                    un(e, function (e, t) {
                        t || -1 != qn(u, e.history) || (An(e.history, s), u.push(e.history)), Gt(e, s, null, Dr(e, s))
                    })
                }
            }
        }
    }

    function Vt(e, t) {
        function r(e) {
            return Ut(e.line + t, e.ch)
        }
        e.first += t, e.cm && at(e.cm, e.first, e.first, t), e.sel.head = r(e.sel.head), e.sel.anchor = r(e.sel.anchor), e.sel.from = r(e.sel.from), e.sel.to = r(e.sel.to)
    }

    function Gt(e, t, r, n) {
        if (e.cm && !e.cm.curOp) return ot(e.cm, Gt)(e, t, r, n);
        if (t.to.line < e.first) return Vt(e, t.text.length - 1 - (t.to.line - t.from.line)), void 0;
        if (!(t.from.line > e.lastLine())) {
            if (t.from.line < e.first) {
                var i = t.text.length - 1 - (e.first - t.from.line);
                Vt(e, i), t = {
                    from: Ut(e.first, 0),
                    to: Ut(t.to.line + i, t.to.ch),
                    text: [Yn(t.text)],
                    origin: t.origin
                }
            }
            var o = e.lastLine();
            t.to.line > o && (t = {
                from: t.from,
                to: Ut(o, fn(e, o).text.length),
                text: [t.text[0]],
                origin: t.origin
            }), t.removed = hn(e, t.from, t.to), r || (r = It(e, t, null)), e.cm ? Bt(e.cm, t, n, r) : ln(e, t, n, r)
        }
    }

    function Bt(e, t, r, n) {
        var o = e.doc,
            l = e.display,
            s = t.from,
            a = t.to,
            u = !1,
            f = s.line;
        e.options.lineWrapping || (f = mn(Fr(o, fn(o, s.line))), o.iter(f, a.line + 1, function (e) {
            return e == l.maxLine ? (u = !0, !0) : void 0
        })), _t(o.sel.head, t.from) || _t(t.to, o.sel.head) || (e.curOp.cursorActivity = !0), ln(o, t, r, n, i(e)), e.options.lineWrapping || (o.iter(f, s.line + t.text.length, function (e) {
            var t = c(o, e);
            t > l.maxLineLength && (l.maxLine = e, l.maxLineLength = t, l.maxLineChanged = !0, u = !1)
        }), u && (e.curOp.updateMaxLine = !0)), o.frontier = Math.min(o.frontier, s.line), E(e, 400);
        var h = t.text.length - (a.line - s.line) - 1;
        if (at(e, s.line, a.line + 1, h), jn(e, "change")) {
            var d = {
                from: s,
                to: a,
                text: t.text,
                removed: t.removed,
                origin: t.origin
            };
            if (e.curOp.textChanged) {
                for (var p = e.curOp.textChanged; p.next; p = p.next);
                p.next = d
            } else e.curOp.textChanged = d
        }
    }

    function jt(e, t, r, n, i) {
        if (n || (n = r), _t(n, r)) {
            var o = n;
            n = r, r = o
        }
        "string" == typeof t && (t = Wo(t)), Pt(e, {
            from: r,
            to: n,
            text: t,
            origin: i
        }, null)
    }

    function Ut(e, t) {
        return this instanceof Ut ? (this.line = e, this.ch = t, void 0) : new Ut(e, t)
    }

    function Kt(e, t) {
        return e.line == t.line && e.ch == t.ch
    }

    function _t(e, t) {
        return e.line < t.line || e.line == t.line && e.ch < t.ch
    }

    function Xt(e) {
        return Ut(e.line, e.ch)
    }

    function Yt(e, t) {
        return Math.max(e.first, Math.min(t, e.first + e.size - 1))
    }

    function $t(e, t) {
        if (t.line < e.first) return Ut(e.first, 0);
        var r = e.first + e.size - 1;
        return t.line > r ? Ut(r, fn(e, r).text.length) : qt(t, fn(e, t.line).text.length)
    }

    function qt(e, t) {
        var r = e.ch;
        return null == r || r > t ? Ut(e.line, t) : 0 > r ? Ut(e.line, 0) : e
    }

    function Zt(e, t) {
        return t >= e.first && t < e.first + e.size
    }

    function Jt(e, t, r, n) {
        if (e.sel.shift || e.sel.extend) {
            var i = e.sel.anchor;
            if (r) {
                var o = _t(t, i);
                o != _t(r, i) ? (i = t, t = r) : o != _t(t, r) && (t = r)
            }
            er(e, i, t, n)
        } else er(e, t, r || t, n);
        e.cm && (e.cm.curOp.userSelChange = !0)
    }

    function Qt(e, t, r) {
        var n = {
            anchor: t,
            head: r
        };
        return Rn(e, "beforeSelectionChange", e, n), e.cm && Rn(e.cm, "beforeSelectionChange", e.cm, n), n.anchor = $t(e, n.anchor), n.head = $t(e, n.head), n
    }

    function er(e, t, r, n, i) {
        if (!i && jn(e, "beforeSelectionChange") || e.cm && jn(e.cm, "beforeSelectionChange")) {
            var o = Qt(e, t, r);
            r = o.head, t = o.anchor
        }
        var l = e.sel;
        if (l.goalColumn = null, (i || !Kt(t, l.anchor)) && (t = rr(e, t, n, "push" != i)), (i || !Kt(r, l.head)) && (r = rr(e, r, n, "push" != i)), !Kt(l.anchor, t) || !Kt(l.head, r)) {
            l.anchor = t, l.head = r;
            var s = _t(r, t);
            l.from = s ? r : t, l.to = s ? t : r, e.cm && (e.cm.curOp.updateInput = e.cm.curOp.selectionChanged = e.cm.curOp.cursorActivity = !0), Vn(e, "cursorActivity", e)
        }
    }

    function tr(e) {
        er(e.doc, e.doc.sel.from, e.doc.sel.to, null, "push")
    }

    function rr(e, t, r, n) {
        var i = !1,
            o = t,
            l = r || 1;
        e.cantEdit = !1;
        e: for (;;) {
            var s = fn(e, o.line);
            if (s.markedSpans)
                for (var a = 0; a < s.markedSpans.length; ++a) {
                    var u = s.markedSpans[a],
                        c = u.marker;
                    if ((null == u.from || (c.inclusiveLeft ? u.from <= o.ch : u.from < o.ch)) && (null == u.to || (c.inclusiveRight ? u.to >= o.ch : u.to > o.ch))) {
                        if (n && (Rn(c, "beforeCursorEnter"), c.explicitlyCleared)) {
                            if (s.markedSpans) {
                                --a;
                                continue
                            }
                            break
                        }
                        if (!c.atomic) continue;
                        var f = c.find()[0 > l ? "from" : "to"];
                        if (Kt(f, o) && (f.ch += l, f.ch < 0 ? f = f.line > e.first ? $t(e, Ut(f.line - 1)) : null : f.ch > s.text.length && (f = f.line < e.first + e.size - 1 ? Ut(f.line + 1, 0) : null), !f)) {
                            if (i) return n ? (e.cantEdit = !0, Ut(e.first, 0)) : rr(e, t, r, !0);
                            i = !0, f = t, l = -l
                        }
                        o = f;
                        continue e
                    }
                }
            return o
        }
    }

    function nr(e) {
        var t = ir(e, e.doc.sel.head, e.options.cursorScrollMargin);
        if (e.state.focused) {
            var r = e.display,
                n = si(r.sizer),
                i = null;
            if (t.top + n.top < 0 ? i = !0 : t.bottom + n.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), null != i && !Ii) {
                var o = "none" == r.cursor.style.display;
                o && (r.cursor.style.display = "", r.cursor.style.left = t.left + "px", r.cursor.style.top = t.top - r.viewOffset + "px"), r.cursor.scrollIntoView(i), o && (r.cursor.style.display = "none")
            }
        }
    }

    function ir(e, t, r) {
        for (null == r && (r = 0);;) {
            var n = !1,
                i = Z(e, t),
                o = lr(e, i.left, i.top - r, i.left, i.bottom + r),
                l = e.doc.scrollTop,
                s = e.doc.scrollLeft;
            if (null != o.scrollTop && (Ct(e, o.scrollTop), Math.abs(e.doc.scrollTop - l) > 1 && (n = !0)), null != o.scrollLeft && (Lt(e, o.scrollLeft), Math.abs(e.doc.scrollLeft - s) > 1 && (n = !0)), !n) return i
        }
    }

    function or(e, t, r, n, i) {
        var o = lr(e, t, r, n, i);
        null != o.scrollTop && Ct(e, o.scrollTop), null != o.scrollLeft && Lt(e, o.scrollLeft)
    }

    function lr(e, t, r, n, i) {
        var o = e.display,
            l = tt(e.display);
        0 > r && (r = 0);
        var s = o.scroller.clientHeight - Lo,
            a = o.scroller.scrollTop,
            u = {}, c = e.doc.height + P(o),
            f = l > r,
            h = i > c - l;
        if (a > r) u.scrollTop = f ? 0 : r;
        else if (i > a + s) {
            var d = Math.min(r, (h ? c : i) - s);
            d != a && (u.scrollTop = d)
        }
        var p = o.scroller.clientWidth - Lo,
            m = o.scroller.scrollLeft;
        t += o.gutters.offsetWidth, n += o.gutters.offsetWidth;
        var g = o.gutters.offsetWidth,
            v = g + 10 > t;
        return m + g > t || v ? (v && (t = 0), u.scrollLeft = Math.max(0, t - 10 - g)) : n > p + m - 3 && (u.scrollLeft = n + 10 - p), u
    }

    function sr(e, t, r) {
        e.curOp.updateScrollPos = {
            scrollLeft: null == t ? e.doc.scrollLeft : t,
            scrollTop: null == r ? e.doc.scrollTop : r
        }
    }

    function ar(e, t, r) {
        var n = e.curOp.updateScrollPos || (e.curOp.updateScrollPos = {
            scrollLeft: e.doc.scrollLeft,
            scrollTop: e.doc.scrollTop
        }),
            i = e.display.scroller;
        n.scrollTop = Math.max(0, Math.min(i.scrollHeight - i.clientHeight, n.scrollTop + r)), n.scrollLeft = Math.max(0, Math.min(i.scrollWidth - i.clientWidth, n.scrollLeft + t))
    }

    function ur(e, t, r, n) {
        var i = e.doc;
        if (null == r && (r = "add"), "smart" == r)
            if (e.doc.mode.indent) var o = I(e, t);
            else r = "prev";
        var l, s = e.options.tabSize,
            a = fn(i, t),
            u = _n(a.text, null, s),
            c = a.text.match(/^\s*/)[0];
        if ("smart" == r && (l = e.doc.mode.indent(o, a.text.slice(c.length), a.text), l == ko)) {
            if (!n) return;
            r = "prev"
        }
        "prev" == r ? l = t > i.first ? _n(fn(i, t - 1).text, null, s) : 0 : "add" == r ? l = u + e.options.indentUnit : "subtract" == r ? l = u - e.options.indentUnit : "number" == typeof r && (l = u + r), l = Math.max(0, l);
        var f = "",
            h = 0;
        if (e.options.indentWithTabs)
            for (var d = Math.floor(l / s); d; --d) h += s, f += "   ";
        l > h && (f += Xn(l - h)), f != c && jt(e.doc, f, Ut(t, 0), Ut(t, c.length), "+input"), a.stateAfter = null
    }

    function cr(e, t, r) {
        var n = t,
            i = t,
            o = e.doc;
        return "number" == typeof t ? i = fn(o, Yt(o, t)) : n = mn(t), null == n ? null : r(i, n) ? (at(e, n, n + 1), i) : null
    }

    function fr(e, t, r, n, i) {
        function o() {
            var t = s + r;
            return t < e.first || t >= e.first + e.size ? f = !1 : (s = t, c = fn(e, t))
        }

        function l(e) {
            var t = (i ? wi : Ci)(c, a, r, !0);
            if (null == t) {
                if (e || !o()) return f = !1;
                a = i ? (0 > r ? mi : pi)(c) : 0 > r ? c.text.length : 0
            } else a = t;
            return !0
        }
        var s = t.line,
            a = t.ch,
            u = r,
            c = fn(e, s),
            f = !0;
        if ("char" == n) l();
        else if ("column" == n) l(!0);
        else if ("word" == n || "group" == n)
            for (var h = null, d = "group" == n, p = !0; !(0 > r) || l(!p); p = !1) {
                var m = c.text.charAt(a) || "\n",
                    g = ti(m) ? "w" : d ? /\s/.test(m) ? null : "p" : null;
                if (h && h != g) {
                    0 > r && (r = 1, l());
                    break
                }
                if (g && (h = g), r > 0 && !l(!p)) break
            }
        var v = rr(e, Ut(s, a), u, !0);
        return f || (v.hitSide = !0), v
    }

    function hr(e, t, r, n) {
        var i, o = e.doc,
            l = t.left;
        if ("page" == n) {
            var s = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            i = t.top + r * (s - (0 > r ? 1.5 : .5) * tt(e.display))
        } else "line" == n && (i = r > 0 ? t.bottom + 3 : t.top - 3);
        for (;;) {
            var a = Q(e, l, i);
            if (!a.outside) break;
            if (0 > r ? 0 >= i : i >= o.height) {
                a.hitSide = !0;
                break
            }
            i += 5 * r
        }
        return a
    }

    function dr(e, t) {
        var r = t.ch,
            n = t.ch;
        if (e) {
            (t.xRel < 0 || n == e.length) && r ? --r : ++n;
            for (var i = e.charAt(r), o = ti(i) ? ti : /\s/.test(i) ? function (e) {
                    return /\s/.test(e)
                } : function (e) {
                    return !/\s/.test(e) && !ti(e)
                }; r > 0 && o(e.charAt(r - 1));)--r;
            for (; n < e.length && o(e.charAt(n));)++n
        }
        return {
            from: Ut(t.line, r),
            to: Ut(t.line, n)
        }
    }

    function pr(e, t) {
        Jt(e.doc, Ut(t, 0), $t(e.doc, Ut(t + 1, 0)))
    }

    function mr(t, r, n, i) {
        e.defaults[t] = r, n && (ro[t] = i ? function (e, t, r) {
            r != io && n(e, t, r)
        } : n)
    }

    function gr(e, t) {
        if (t === !0) return t;
        if (e.copyState) return e.copyState(t);
        var r = {};
        for (var n in t) {
            var i = t[n];
            i instanceof Array && (i = i.concat([])), r[n] = i
        }
        return r
    }

    function vr(e, t, r) {
        return e.startState ? e.startState(t, r) : !0
    }

    function yr(e) {
        return "string" == typeof e ? fo[e] : e
    }

    function br(e, t, r) {
        function n(t) {
            t = yr(t);
            var i = t[e];
            if (i === !1) return "stop";
            if (null != i && r(i)) return !0;
            if (t.nofallthrough) return "stop";
            var o = t.fallthrough;
            if (null == o) return !1;
            if ("[object Array]" != Object.prototype.toString.call(o)) return n(o);
            for (var l = 0, s = o.length; s > l; ++l) {
                var a = n(o[l]);
                if (a) return a
            }
            return !1
        }
        for (var i = 0; i < t.length; ++i) {
            var o = n(t[i]);
            if (o) return "stop" != o
        }
    }

    function xr(e) {
        var t = Oo[e.keyCode];
        return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t
    }

    function wr(e, t) {
        if (Hi && 34 == e.keyCode && e["char"]) return !1;
        var r = Oo[e.keyCode];
        return null == r || e.altGraphKey ? !1 : (e.altKey && (r = "Alt-" + r), (Ui ? e.metaKey : e.ctrlKey) && (r = "Ctrl-" + r), (Ui ? e.ctrlKey : e.metaKey) && (r = "Cmd-" + r), !t && e.shiftKey && (r = "Shift-" + r), r)
    }

    function Cr(e, t) {
        this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0
    }

    function Lr(e, t) {
        this.lines = [], this.type = t, this.doc = e
    }

    function kr(e, t, r, n, i) {
        if (n && n.shared) return Mr(e, t, r, n, i);
        if (e.cm && !e.cm.curOp) return ot(e.cm, kr)(e, t, r, n, i);
        var o = new Lr(e, i);
        if ("range" == i && !_t(t, r)) return o;
        n && Jn(n, o), o.replacedWith && (o.collapsed = !0, o.replacedWith = ni("span", [o.replacedWith], "CodeMirror-widget"), n.handleMouseEvents || (o.replacedWith.ignoreEvents = !0)), o.collapsed && (Xi = !0), o.addToHistory && Cn(e, {
            from: t,
            to: r,
            origin: "markText"
        }, {
            head: e.sel.head,
            anchor: e.sel.anchor
        }, 0 / 0);
        var l, s, a, u = t.line,
            c = 0,
            f = e.cm;
        if (e.iter(u, r.line + 1, function (n) {
            f && o.collapsed && !f.options.lineWrapping && Fr(e, n) == f.display.maxLine && (a = !0);
            var i = {
                from: null,
                to: null,
                marker: o
            };
            c += n.text.length, u == t.line && (i.from = t.ch, c -= t.ch), u == r.line && (i.to = r.ch, c -= n.text.length - r.ch), o.collapsed && (u == r.line && (s = Ir(n, r.ch)), u == t.line ? l = Ir(n, t.ch) : pn(n, 0)), Nr(n, i), ++u
        }), o.collapsed && e.iter(t.line, r.line + 1, function (t) {
            Rr(e, t) && pn(t, 0)
        }), o.clearOnEnter && Pn(o, "beforeCursorEnter", function () {
            o.clear()
        }), o.readOnly && (_i = !0, (e.history.done.length || e.history.undone.length) && e.clearHistory()), o.collapsed) {
            if (l != s) throw new Error("Inserting collapsed marker overlapping an existing one");
            o.size = c, o.atomic = !0
        }
        return f && (a && (f.curOp.updateMaxLine = !0), (o.className || o.title || o.startStyle || o.endStyle || o.collapsed) && at(f, t.line, r.line + 1), o.atomic && tr(f)), o
    }

    function Sr(e, t) {
        this.markers = e, this.primary = t;
        for (var r = 0, n = this; r < e.length; ++r) e[r].parent = this, Pn(e[r], "clear", function () {
            n.clear()
        })
    }

    function Mr(e, t, r, n, i) {
        n = Jn(n), n.shared = !1;
        var o = [kr(e, t, r, n, i)],
            l = o[0],
            s = n.replacedWith;
        return un(e, function (e) {
            s && (n.replacedWith = s.cloneNode(!0)), o.push(kr(e, $t(e, t), $t(e, r), n, i));
            for (var a = 0; a < e.linked.length; ++a)
                if (e.linked[a].isParent) return;
            l = Yn(o)
        }), new Sr(o, l)
    }

    function Tr(e, t) {
        if (e)
            for (var r = 0; r < e.length; ++r) {
                var n = e[r];
                if (n.marker == t) return n
            }
    }

    function Ar(e, t) {
        for (var r, n = 0; n < e.length; ++n) e[n] != t && (r || (r = [])).push(e[n]);
        return r
    }

    function Nr(e, t) {
        e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e)
    }

    function Hr(e, t, r) {
        if (e)
            for (var n, i = 0; i < e.length; ++i) {
                var o = e[i],
                    l = o.marker,
                    s = null == o.from || (l.inclusiveLeft ? o.from <= t : o.from < t);
                if (s || "bookmark" == l.type && o.from == t && (!r || !o.marker.insertLeft)) {
                    var a = null == o.to || (l.inclusiveRight ? o.to >= t : o.to > t);
                    (n || (n = [])).push({
                        from: o.from,
                        to: a ? null : o.to,
                        marker: l
                    })
                }
            }
        return n
    }

    function Wr(e, t, r) {
        if (e)
            for (var n, i = 0; i < e.length; ++i) {
                var o = e[i],
                    l = o.marker,
                    s = null == o.to || (l.inclusiveRight ? o.to >= t : o.to > t);
                if (s || "bookmark" == l.type && o.from == t && (!r || o.marker.insertLeft)) {
                    var a = null == o.from || (l.inclusiveLeft ? o.from <= t : o.from < t);
                    (n || (n = [])).push({
                        from: a ? null : o.from - t,
                        to: null == o.to ? null : o.to - t,
                        marker: l
                    })
                }
            }
        return n
    }

    function Er(e, t) {
        var r = Zt(e, t.from.line) && fn(e, t.from.line).markedSpans,
            n = Zt(e, t.to.line) && fn(e, t.to.line).markedSpans;
        if (!r && !n) return null;
        var i = t.from.ch,
            o = t.to.ch,
            l = Kt(t.from, t.to),
            s = Hr(r, i, l),
            a = Wr(n, o, l),
            u = 1 == t.text.length,
            c = Yn(t.text).length + (u ? i : 0);
        if (s)
            for (var f = 0; f < s.length; ++f) {
                var h = s[f];
                if (null == h.to) {
                    var d = Tr(a, h.marker);
                    d ? u && (h.to = null == d.to ? null : d.to + c) : h.to = i
                }
            }
        if (a)
            for (var f = 0; f < a.length; ++f) {
                var h = a[f];
                if (null != h.to && (h.to += c), null == h.from) {
                    var d = Tr(s, h.marker);
                    d || (h.from = c, u && (s || (s = [])).push(h))
                } else h.from += c, u && (s || (s = [])).push(h)
            }
        if (u && s) {
            for (var f = 0; f < s.length; ++f) null != s[f].from && s[f].from == s[f].to && "bookmark" != s[f].marker.type && s.splice(f--, 1);
            s.length || (s = null)
        }
        var p = [s];
        if (!u) {
            var m, g = t.text.length - 2;
            if (g > 0 && s)
                for (var f = 0; f < s.length; ++f) null == s[f].to && (m || (m = [])).push({
                    from: null,
                    to: null,
                    marker: s[f].marker
                });
            for (var f = 0; g > f; ++f) p.push(m);
            p.push(a)
        }
        return p
    }

    function Dr(e, t) {
        var r = kn(e, t),
            n = Er(e, t);
        if (!r) return n;
        if (!n) return r;
        for (var i = 0; i < r.length; ++i) {
            var o = r[i],
                l = n[i];
            if (o && l) e: for (var s = 0; s < l.length; ++s) {
                for (var a = l[s], u = 0; u < o.length; ++u)
                    if (o[u].marker == a.marker) continue e;
                o.push(a)
            } else l && (r[i] = l)
        }
        return r
    }

    function Or(e, t, r) {
        var n = null;
        if (e.iter(t.line, r.line + 1, function (e) {
            if (e.markedSpans)
                for (var t = 0; t < e.markedSpans.length; ++t) {
                    var r = e.markedSpans[t].marker;
                    !r.readOnly || n && -1 != qn(n, r) || (n || (n = [])).push(r)
                }
        }), !n) return null;
        for (var i = [{
            from: t,
            to: r
        }], o = 0; o < n.length; ++o)
            for (var l = n[o], s = l.find(), a = 0; a < i.length; ++a) {
                var u = i[a];
                if (!_t(u.to, s.from) && !_t(s.to, u.from)) {
                    var c = [a, 1];
                    (_t(u.from, s.from) || !l.inclusiveLeft && Kt(u.from, s.from)) && c.push({
                        from: u.from,
                        to: s.from
                    }), (_t(s.to, u.to) || !l.inclusiveRight && Kt(u.to, s.to)) && c.push({
                        from: s.to,
                        to: u.to
                    }), i.splice.apply(i, c), a += c.length - 1
                }
            }
        return i
    }

    function Ir(e, t) {
        var r, n = Xi && e.markedSpans;
        if (n)
            for (var i, o = 0; o < n.length; ++o) i = n[o], i.marker.collapsed && (null == i.from || i.from < t) && (null == i.to || i.to > t) && (!r || r.width < i.marker.width) && (r = i.marker);
        return r
    }

    function zr(e) {
        return Ir(e, -1)
    }

    function Pr(e) {
        return Ir(e, e.text.length + 1)
    }

    function Fr(e, t) {
        for (var r; r = zr(t);) t = fn(e, r.find().from.line);
        return t
    }

    function Rr(e, t) {
        var r = Xi && t.markedSpans;
        if (r)
            for (var n, i = 0; i < r.length; ++i)
                if (n = r[i], n.marker.collapsed) {
                    if (null == n.from) return !0;
                    if (!n.marker.replacedWith && 0 == n.from && n.marker.inclusiveLeft && Vr(e, t, n)) return !0
                }
    }

    function Vr(e, t, r) {
        if (null == r.to) {
            var n = r.marker.find().to,
                i = fn(e, n.line);
            return Vr(e, i, Tr(i.markedSpans, r.marker))
        }
        if (r.marker.inclusiveRight && r.to == t.text.length) return !0;
        for (var o, l = 0; l < t.markedSpans.length; ++l)
            if (o = t.markedSpans[l], o.marker.collapsed && !o.marker.replacedWith && o.from == r.to && (o.marker.inclusiveLeft || r.marker.inclusiveRight) && Vr(e, t, o)) return !0
    }

    function Gr(e) {
        var t = e.markedSpans;
        if (t) {
            for (var r = 0; r < t.length; ++r) t[r].marker.detachLine(e);
            e.markedSpans = null
        }
    }

    function Br(e, t) {
        if (t) {
            for (var r = 0; r < t.length; ++r) t[r].marker.attachLine(e);
            e.markedSpans = t
        }
    }

    function jr(e) {
        return function () {
            var t = !this.cm.curOp;
            t && nt(this.cm);
            try {
                var r = e.apply(this, arguments)
            } finally {
                t && it(this.cm)
            }
            return r
        }
    }

    function Ur(e) {
        return null != e.height ? e.height : (e.node.parentNode && 1 == e.node.parentNode.nodeType || oi(e.cm.display.measure, ni("div", [e.node], null, "position: relative")), e.height = e.node.offsetHeight)
    }

    function Kr(e, t, r, n) {
        var i = new ho(e, r, n);
        return i.noHScroll && (e.display.alignWidgets = !0), cr(e, t, function (t) {
            var r = t.widgets || (t.widgets = []);
            if (null == i.insertAt ? r.push(i) : r.splice(Math.min(r.length - 1, Math.max(0, i.insertAt)), 0, i), i.line = t, !Rr(e.doc, t) || i.showIfHidden) {
                var n = vn(e, t) < e.doc.scrollTop;
                pn(t, t.height + Ur(i)), n && ar(e, 0, i.height)
            }
            return !0
        }), i
    }

    function _r(e, t, r, n) {
        e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), null != e.order && (e.order = null), Gr(e), Br(e, r);
        var i = n ? n(e) : 1;
        i != e.height && pn(e, i)
    }

    function Xr(e) {
        e.parent = null, Gr(e)
    }

    function Yr(e, t, r, n, i) {
        var o = r.flattenSpans;
        null == o && (o = e.options.flattenSpans);
        var l, s = 0,
            a = null,
            u = new Cr(t, e.options.tabSize);
        for ("" == t && r.blankLine && r.blankLine(n); !u.eol();) u.pos > e.options.maxHighlightLength ? (o = !1, u.pos = Math.min(t.length, u.start + 5e4), l = null) : l = r.token(u, n), o && a == l || (s < u.start && i(u.start, a), s = u.start, a = l), u.start = u.pos;
        s < u.pos && i(u.pos, a)
    }

    function $r(e, t, r) {
        var n = [e.state.modeGen];
        Yr(e, t.text, e.doc.mode, r, function (e, t) {
            n.push(e, t)
        });
        for (var i = 0; i < e.state.overlays.length; ++i) {
            var o = e.state.overlays[i],
                l = 1,
                s = 0;
            Yr(e, t.text, o.mode, !0, function (e, t) {
                for (var r = l; e > s;) {
                    var i = n[l];
                    i > e && n.splice(l, 1, e, n[l + 1], i), l += 2, s = Math.min(e, i)
                }
                if (t)
                    if (o.opaque) n.splice(r, l - r, e, t), l = r + 2;
                    else
                        for (; l > r; r += 2) {
                            var a = n[r + 1];
                            n[r + 1] = a ? a + " " + t : t
                        }
            })
        }
        return n
    }

    function qr(e, t) {
        return t.styles && t.styles[0] == e.state.modeGen || (t.styles = $r(e, t, t.stateAfter = I(e, mn(t)))), t.styles
    }

    function Zr(e, t, r) {
        var n = e.doc.mode,
            i = new Cr(t.text, e.options.tabSize);
        for ("" == t.text && n.blankLine && n.blankLine(r); !i.eol() && i.pos <= e.options.maxHighlightLength;) n.token(i, r), i.start = i.pos
    }

    function Jr(e) {
        return e ? mo[e] || (mo[e] = "cm-" + e.replace(/ +/g, " cm-")) : null
    }

    function Qr(e, t, r, n) {
        for (var i, o = t, l = !0; i = zr(o);) o = fn(e.doc, i.find().from.line);
        var s = {
            pre: ni("pre"),
            col: 0,
            pos: 0,
            measure: null,
            measuredSomething: !1,
            cm: e,
            copyWidgets: n
        };
        o.textClass && (s.pre.className = o.textClass);
        do {
            o.text && (l = !1), s.measure = o == t && r, s.pos = 0, s.addToken = s.measure ? tn : en, (ki || Ti) && e.getOption("lineWrapping") && (s.addToken = rn(s.addToken));
            var a = on(o, s, qr(e, o));
            r && o == t && !s.measuredSomething && (r[0] = s.pre.appendChild(ci(e.display.measure)), s.measuredSomething = !0), a && (o = fn(e.doc, a.to.line))
        } while (a);
        !r || s.measuredSomething || r[0] || (r[0] = s.pre.appendChild(l ? ni("span", "\xa0") : ci(e.display.measure))), s.pre.firstChild || Rr(e.doc, t) || s.pre.appendChild(document.createTextNode("\xa0"));
        var u;
        if (r && ki && (u = yn(o))) {
            var c = u.length - 1;
            u[c].from == u[c].to && --c;
            var f = u[c],
                h = u[c - 1];
            if (f.from + 1 == f.to && h && f.level < h.level) {
                var d = r[s.pos - 1];
                d && d.parentNode.insertBefore(d.measureRight = ci(e.display.measure), d.nextSibling)
            }
        }
        return Rn(e, "renderLine", e, t, s.pre), s.pre
    }

    function en(e, t, r, n, i, o) {
        if (t) {
            if (go.test(t))
                for (var l = document.createDocumentFragment(), s = 0;;) {
                    go.lastIndex = s;
                    var a = go.exec(t),
                        u = a ? a.index - s : t.length - s;
                    if (u && (l.appendChild(document.createTextNode(t.slice(s, s + u))), e.col += u), !a) break;
                    if (s += u + 1, "   " == a[0]) {
                        var c = e.cm.options.tabSize,
                            f = c - e.col % c;
                        l.appendChild(ni("span", Xn(f), "cm-tab")), e.col += f
                    } else {
                        var h = ni("span", "\u2022", "cm-invalidchar");
                        h.title = "\\u" + a[0].charCodeAt(0).toString(16), l.appendChild(h), e.col += 1
                    }
                } else {
                    e.col += t.length;
                    var l = document.createTextNode(t)
                } if (r || n || i || e.measure) {
                    var d = r || "";
                    n && (d += n), i && (d += i);
                    var h = ni("span", [l], d);
                    return o && (h.title = o), e.pre.appendChild(h)
                }
            e.pre.appendChild(l)
        }
    }

    function tn(e, t, r, n, i) {
        for (var o = e.cm.options.lineWrapping, l = 0; l < t.length; ++l) {
            var s = t.charAt(l),
                a = 0 == l;
            s >= "\ud800" && "\udbff" > s && l < t.length - 1 ? (s = t.slice(l, l + 2), ++l) : l && o && ai(t, l) && e.pre.appendChild(ni("wbr"));
            var u = e.measure[e.pos],
                c = e.measure[e.pos] = en(e, s, r, a && n, l == t.length - 1 && i);
            u && (c.leftSide = u.leftSide || u), ki && o && " " == s && l && !/\s/.test(t.charAt(l - 1)) && l < t.length - 1 && !/\s/.test(t.charAt(l + 1)) && (c.style.whiteSpace = "normal"), e.pos += s.length
        }
        t.length && (e.measuredSomething = !0)
    }

    function rn(e) {
        function t(e) {
            for (var t = " ", r = 0; r < e.length - 2; ++r) t += r % 2 ? " " : "\xa0";
            return t += " "
        }
        return function (r, n, i, o, l, s) {
            return e(r, n.replace(/ {3,}/, t), i, o, l, s)
        }
    }

    function nn(e, t, r, n) {
        var i = !n && r.replacedWith;
        if (i && (e.copyWidgets && (i = i.cloneNode(!0)), e.pre.appendChild(i), e.measure)) {
            if (t) e.measure[e.pos] = i;
            else {
                var o = e.measure[e.pos] = ci(e.cm.display.measure);
                "bookmark" != r.type || r.insertLeft ? e.pre.insertBefore(o, i) : e.pre.appendChild(o)
            }
            e.measuredSomething = !0
        }
        e.pos += t
    }

    function on(e, t, r) {
        var n = e.markedSpans,
            i = e.text,
            o = 0;
        if (n)
            for (var l, s, a, u, c, f, h = i.length, d = 0, p = 1, m = "", g = 0;;) {
                if (g == d) {
                    s = a = u = c = "", f = null, g = 1 / 0;
                    for (var v = null, y = 0; y < n.length; ++y) {
                        var b = n[y],
                            x = b.marker;
                        b.from <= d && (null == b.to || b.to > d) ? (null != b.to && g > b.to && (g = b.to, a = ""), x.className && (s += " " + x.className), x.startStyle && b.from == d && (u += " " + x.startStyle), x.endStyle && b.to == g && (a += " " + x.endStyle), x.title && !c && (c = x.title), x.collapsed && (!f || f.marker.size < x.size) && (f = b)) : b.from > d && g > b.from && (g = b.from), "bookmark" == x.type && b.from == d && x.replacedWith && (v = x)
                    }
                    if (f && (f.from || 0) == d && (nn(t, (null == f.to ? h : f.to) - d, f.marker, null == f.from), null == f.to)) return f.marker.find();
                    v && !f && nn(t, 0, v)
                }
                if (d >= h) break;
                for (var w = Math.min(h, g);;) {
                    if (m) {
                        var C = d + m.length;
                        if (!f) {
                            var L = C > w ? m.slice(0, w - d) : m;
                            t.addToken(t, L, l ? l + s : s, u, d + L.length == g ? a : "", c)
                        }
                        if (C >= w) {
                            m = m.slice(w - d), d = w;
                            break
                        }
                        d = C, u = ""
                    }
                    m = i.slice(o, o = r[p++]), l = Jr(r[p++])
                }
            } else
                for (var p = 1; p < r.length; p += 2) t.addToken(t, i.slice(o, o = r[p]), Jr(r[p + 1]))
    }

    function ln(e, t, r, n, i) {
        function o(e) {
            return r ? r[e] : null
        }

        function l(e, r, n) {
            _r(e, r, n, i), Vn(e, "change", e, t)
        }
        var s = t.from,
            a = t.to,
            u = t.text,
            c = fn(e, s.line),
            f = fn(e, a.line),
            h = Yn(u),
            d = o(u.length - 1),
            p = a.line - s.line;
        if (0 == s.ch && 0 == a.ch && "" == h) {
            for (var m = 0, g = u.length - 1, v = []; g > m; ++m) v.push(new po(u[m], o(m), i));
            l(f, f.text, d), p && e.remove(s.line, p), v.length && e.insert(s.line, v)
        } else if (c == f)
            if (1 == u.length) l(c, c.text.slice(0, s.ch) + h + c.text.slice(a.ch), d);
            else {
                for (var v = [], m = 1, g = u.length - 1; g > m; ++m) v.push(new po(u[m], o(m), i));
                v.push(new po(h + c.text.slice(a.ch), d, i)), l(c, c.text.slice(0, s.ch) + u[0], o(0)), e.insert(s.line + 1, v)
            } else if (1 == u.length) l(c, c.text.slice(0, s.ch) + u[0] + f.text.slice(a.ch), o(0)), e.remove(s.line + 1, p);
        else {
            l(c, c.text.slice(0, s.ch) + u[0], o(0)), l(f, h + f.text.slice(a.ch), d);
            for (var m = 1, g = u.length - 1, v = []; g > m; ++m) v.push(new po(u[m], o(m), i));
            p > 1 && e.remove(s.line + 1, p - 1), e.insert(s.line + 1, v)
        }
        Vn(e, "change", e, t), er(e, n.anchor, n.head, null, !0)
    }

    function sn(e) {
        this.lines = e, this.parent = null;
        for (var t = 0, r = e.length, n = 0; r > t; ++t) e[t].parent = this, n += e[t].height;
        this.height = n
    }

    function an(e) {
        this.children = e;
        for (var t = 0, r = 0, n = 0, i = e.length; i > n; ++n) {
            var o = e[n];
            t += o.chunkSize(), r += o.height, o.parent = this
        }
        this.size = t, this.height = r, this.parent = null
    }

    function un(e, t, r) {
        function n(e, i, o) {
            if (e.linked)
                for (var l = 0; l < e.linked.length; ++l) {
                    var s = e.linked[l];
                    if (s.doc != i) {
                        var a = o && s.sharedHist;
                        (!r || a) && (t(s.doc, a), n(s.doc, e, a))
                    }
                }
        }
        n(e, null, !0)
    }

    function cn(e, t) {
        if (t.cm) throw new Error("This document is already in use.");
        e.doc = t, t.cm = e, o(e), r(e), e.options.lineWrapping || f(e), e.options.mode = t.modeOption, at(e)
    }

    function fn(e, t) {
        for (t -= e.first; !e.lines;)
            for (var r = 0;; ++r) {
                var n = e.children[r],
                    i = n.chunkSize();
                if (i > t) {
                    e = n;
                    break
                }
                t -= i
            }
        return e.lines[t]
    }

    function hn(e, t, r) {
        var n = [],
            i = t.line;
        return e.iter(t.line, r.line + 1, function (e) {
            var o = e.text;
            i == r.line && (o = o.slice(0, r.ch)), i == t.line && (o = o.slice(t.ch)), n.push(o), ++i
        }), n
    }

    function dn(e, t, r) {
        var n = [];
        return e.iter(t, r, function (e) {
            n.push(e.text)
        }), n
    }

    function pn(e, t) {
        for (var r = t - e.height, n = e; n; n = n.parent) n.height += r
    }

    function mn(e) {
        if (null == e.parent) return null;
        for (var t = e.parent, r = qn(t.lines, e), n = t.parent; n; t = n, n = n.parent)
            for (var i = 0; n.children[i] != t; ++i) r += n.children[i].chunkSize();
        return r + t.first
    }

    function gn(e, t) {
        var r = e.first;
        e: do {
            for (var n = 0, i = e.children.length; i > n; ++n) {
                var o = e.children[n],
                    l = o.height;
                if (l > t) {
                    e = o;
                    continue e
                }
                t -= l, r += o.chunkSize()
            }
            return r
        } while (!e.lines);
        for (var n = 0, i = e.lines.length; i > n; ++n) {
            var s = e.lines[n],
                a = s.height;
            if (a > t) break;
            t -= a
        }
        return r + n
    }

    function vn(e, t) {
        t = Fr(e.doc, t);
        for (var r = 0, n = t.parent, i = 0; i < n.lines.length; ++i) {
            var o = n.lines[i];
            if (o == t) break;
            r += o.height
        }
        for (var l = n.parent; l; n = l, l = n.parent)
            for (var i = 0; i < l.children.length; ++i) {
                var s = l.children[i];
                if (s == n) break;
                r += s.height
            }
        return r
    }

    function yn(e) {
        var t = e.order;
        return null == t && (t = e.order = zo(e.text)), t
    }

    function bn(e) {
        return {
            done: [],
            undone: [],
            undoDepth: 1 / 0,
            lastTime: 0,
            lastOp: null,
            lastOrigin: null,
            generation: e || 1,
            maxGeneration: e || 1
        }
    }

    function xn(e, t, r, n) {
        var i = t["spans_" + e.id],
            o = 0;
        e.iter(Math.max(e.first, r), Math.min(e.first + e.size, n), function (r) {
            r.markedSpans && ((i || (i = t["spans_" + e.id] = {}))[o] = r.markedSpans), ++o
        })
    }

    function wn(e, t) {
        var r = {
            line: t.from.line,
            ch: t.from.ch
        }, n = {
                from: r,
                to: to(t),
                text: hn(e, t.from, t.to)
            };
        return xn(e, n, t.from.line, t.to.line + 1), un(e, function (e) {
            xn(e, n, t.from.line, t.to.line + 1)
        }, !0), n
    }

    function Cn(e, t, r, n) {
        var i = e.history;
        i.undone.length = 0;
        var o = +new Date,
            l = Yn(i.done);
        if (l && (i.lastOp == n || i.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && e.cm && i.lastTime > o - e.cm.options.historyEventDelay || "*" == t.origin.charAt(0)))) {
            var s = Yn(l.changes);
            Kt(t.from, t.to) && Kt(t.from, s.to) ? s.to = to(t) : l.changes.push(wn(e, t)), l.anchorAfter = r.anchor, l.headAfter = r.head
        } else
            for (l = {
                changes: [wn(e, t)],
                generation: i.generation,
                anchorBefore: e.sel.anchor,
                headBefore: e.sel.head,
                anchorAfter: r.anchor,
                headAfter: r.head
            }, i.done.push(l), i.generation = ++i.maxGeneration; i.done.length > i.undoDepth;) i.done.shift();
        i.lastTime = o, i.lastOp = n, i.lastOrigin = t.origin
    }

    function Ln(e) {
        if (!e) return null;
        for (var t, r = 0; r < e.length; ++r) e[r].marker.explicitlyCleared ? t || (t = e.slice(0, r)) : t && t.push(e[r]);
        return t ? t.length ? t : null : e
    }

    function kn(e, t) {
        var r = t["spans_" + e.id];
        if (!r) return null;
        for (var n = 0, i = []; n < t.text.length; ++n) i.push(Ln(r[n]));
        return i
    }

    function Sn(e, t) {
        for (var r = 0, n = []; r < e.length; ++r) {
            var i = e[r],
                o = i.changes,
                l = [];
            n.push({
                changes: l,
                anchorBefore: i.anchorBefore,
                headBefore: i.headBefore,
                anchorAfter: i.anchorAfter,
                headAfter: i.headAfter
            });
            for (var s = 0; s < o.length; ++s) {
                var a, u = o[s];
                if (l.push({
                    from: u.from,
                    to: u.to,
                    text: u.text
                }), t)
                    for (var c in u)(a = c.match(/^spans_(\d+)$/)) && qn(t, Number(a[1])) > -1 && (Yn(l)[c] = u[c], delete u[c])
            }
        }
        return n
    }

    function Mn(e, t, r, n) {
        r < e.line ? e.line += n : t < e.line && (e.line = t, e.ch = 0)
    }

    function Tn(e, t, r, n) {
        for (var i = 0; i < e.length; ++i) {
            for (var o = e[i], l = !0, s = 0; s < o.changes.length; ++s) {
                var a = o.changes[s];
                if (o.copied || (a.from = Xt(a.from), a.to = Xt(a.to)), r < a.from.line) a.from.line += n, a.to.line += n;
                else if (t <= a.to.line) {
                    l = !1;
                    break
                }
            }
            o.copied || (o.anchorBefore = Xt(o.anchorBefore), o.headBefore = Xt(o.headBefore), o.anchorAfter = Xt(o.anchorAfter), o.readAfter = Xt(o.headAfter), o.copied = !0), l ? (Mn(o.anchorBefore), Mn(o.headBefore), Mn(o.anchorAfter), Mn(o.headAfter)) : (e.splice(0, i + 1), i = 0)
        }
    }

    function An(e, t) {
        var r = t.from.line,
            n = t.to.line,
            i = t.text.length - (n - r) - 1;
        Tn(e.done, r, n, i), Tn(e.undone, r, n, i)
    }

    function Nn() {
        On(this)
    }

    function Hn(e) {
        return e.stop || (e.stop = Nn), e
    }

    function Wn(e) {
        e.preventDefault ? e.preventDefault() : e.returnValue = !1
    }

    function En(e) {
        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
    }

    function Dn(e) {
        return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
    }

    function On(e) {
        Wn(e), En(e)
    }

    function In(e) {
        return e.target || e.srcElement
    }

    function zn(e) {
        var t = e.which;
        return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), Fi && e.ctrlKey && 1 == t && (t = 3), t
    }

    function Pn(e, t, r) {
        if (e.addEventListener) e.addEventListener(t, r, !1);
        else if (e.attachEvent) e.attachEvent("on" + t, r);
        else {
            var n = e._handlers || (e._handlers = {}),
                i = n[t] || (n[t] = []);
            i.push(r)
        }
    }

    function Fn(e, t, r) {
        if (e.removeEventListener) e.removeEventListener(t, r, !1);
        else if (e.detachEvent) e.detachEvent("on" + t, r);
        else {
            var n = e._handlers && e._handlers[t];
            if (!n) return;
            for (var i = 0; i < n.length; ++i)
                if (n[i] == r) {
                    n.splice(i, 1);
                    break
                }
        }
    }

    function Rn(e, t) {
        var r = e._handlers && e._handlers[t];
        if (r)
            for (var n = Array.prototype.slice.call(arguments, 2), i = 0; i < r.length; ++i) r[i].apply(null, n)
    }

    function Vn(e, t) {
        function r(e) {
            return function () {
                e.apply(null, i)
            }
        }
        var n = e._handlers && e._handlers[t];
        if (n) {
            var i = Array.prototype.slice.call(arguments, 2);
            wo || (++Co, wo = [], setTimeout(Bn, 0));
            for (var o = 0; o < n.length; ++o) wo.push(r(n[o]))
        }
    }

    function Gn(e, t, r) {
        return Rn(e, r || t.type, e, t), Dn(t) || t.codemirrorIgnore
    }

    function Bn() {
        --Co;
        var e = wo;
        wo = null;
        for (var t = 0; t < e.length; ++t) e[t]()
    }

    function jn(e, t) {
        var r = e._handlers && e._handlers[t];
        return r && r.length > 0
    }

    function Un(e) {
        e.prototype.on = function (e, t) {
            Pn(this, e, t)
        }, e.prototype.off = function (e, t) {
            Fn(this, e, t)
        }
    }

    function Kn() {
        this.id = null
    }

    function _n(e, t, r, n, i) {
        null == t && (t = e.search(/[^\s\u00a0]/), -1 == t && (t = e.length));
        for (var o = n || 0, l = i || 0; t > o; ++o) "   " == e.charAt(o) ? l += r - l % r : ++l;
        return l
    }

    function Xn(e) {
        for (; So.length <= e;) So.push(Yn(So) + " ");
        return So[e]
    }

    function Yn(e) {
        return e[e.length - 1]
    }

    function $n(e) {
        if (zi) e.selectionStart = 0, e.selectionEnd = e.value.length;
        else try {
            e.select()
        } catch (t) {}
    }

    function qn(e, t) {
        if (e.indexOf) return e.indexOf(t);
        for (var r = 0, n = e.length; n > r; ++r)
            if (e[r] == t) return r;
        return -1
    }

    function Zn(e, t) {
        function r() {}
        r.prototype = e;
        var n = new r;
        return t && Jn(t, n), n
    }

    function Jn(e, t) {
        t || (t = {});
        for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]);
        return t
    }

    function Qn(e) {
        for (var t = [], r = 0; e > r; ++r) t.push(void 0);
        return t
    }

    function ei(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return function () {
            return e.apply(null, t)
        }
    }

    function ti(e) {
        return /\w/.test(e) || e > "\x80" && (e.toUpperCase() != e.toLowerCase() || Mo.test(e))
    }

    function ri(e) {
        for (var t in e)
            if (e.hasOwnProperty(t) && e[t]) return !1;
        return !0
    }

    function ni(e, t, r, n) {
        var i = document.createElement(e);
        if (r && (i.className = r), n && (i.style.cssText = n), "string" == typeof t) li(i, t);
        else if (t)
            for (var o = 0; o < t.length; ++o) i.appendChild(t[o]);
        return i
    }

    function ii(e) {
        for (var t = e.childNodes.length; t > 0; --t) e.removeChild(e.firstChild);
        return e
    }

    function oi(e, t) {
        return ii(e).appendChild(t)
    }

    function li(e, t) {
        Mi ? (e.innerHTML = "", e.appendChild(document.createTextNode(t))) : e.textContent = t
    }

    function si(e) {
        return e.getBoundingClientRect()
    }

    function ai() {
        return !1
    }

    function ui(e) {
        if (null != No) return No;
        var t = ni("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
        return oi(e, t), t.offsetWidth && (No = t.offsetHeight - t.clientHeight), No || 0
    }

    function ci(e) {
        if (null == Ho) {
            var t = ni("span", "\u200b");
            oi(e, ni("span", [t, document.createTextNode("x")])), 0 != e.firstChild.offsetHeight && (Ho = t.offsetWidth <= 1 && t.offsetHeight > 2 && !Si)
        }
        return Ho ? ni("span", "\u200b") : ni("span", "\xa0", null, "display: inline-block; width: 1px; margin-right: -1px")
    }

    function fi(e, t, r, n) {
        if (!e) return n(t, r, "ltr");
        for (var i = !1, o = 0; o < e.length; ++o) {
            var l = e[o];
            (l.from < r && l.to > t || t == r && l.to == t) && (n(Math.max(l.from, t), Math.min(l.to, r), 1 == l.level ? "rtl" : "ltr"), i = !0)
        }
        i || n(t, r, "ltr")
    }

    function hi(e) {
        return e.level % 2 ? e.to : e.from
    }

    function di(e) {
        return e.level % 2 ? e.from : e.to
    }

    function pi(e) {
        var t = yn(e);
        return t ? hi(t[0]) : 0
    }

    function mi(e) {
        var t = yn(e);
        return t ? di(Yn(t)) : e.text.length
    }

    function gi(e, t) {
        var r = fn(e.doc, t),
            n = Fr(e.doc, r);
        n != r && (t = mn(n));
        var i = yn(n),
            o = i ? i[0].level % 2 ? mi(n) : pi(n) : 0;
        return Ut(t, o)
    }

    function vi(e, t) {
        for (var r, n; r = Pr(n = fn(e.doc, t));) t = r.find().to.line;
        var i = yn(n),
            o = i ? i[0].level % 2 ? pi(n) : mi(n) : n.text.length;
        return Ut(t, o)
    }

    function yi(e, t, r) {
        var n = e[0].level;
        return t == n ? !0 : r == n ? !1 : r > t
    }

    function bi(e, t) {
        for (var r, n = 0; n < e.length; ++n) {
            var i = e[n];
            if (i.from < t && i.to > t) return Io = null, n;
            if (i.from == t || i.to == t) {
                if (null != r) return yi(e, i.level, e[r].level) ? (Io = r, n) : (Io = n, r);
                r = n
            }
        }
        return Io = null, r
    }

    function xi(e, t, r, n) {
        if (!n) return t + r;
        do t += r; while (t > 0 && To.test(e.text.charAt(t)));
        return t
    }

    function wi(e, t, r, n) {
        var i = yn(e);
        if (!i) return Ci(e, t, r, n);
        for (var o = bi(i, t), l = i[o], s = xi(e, t, l.level % 2 ? -r : r, n);;) {
            if (s > l.from && s < l.to) return s;
            if (s == l.from || s == l.to) return bi(i, s) == o ? s : (l = i[o += r], r > 0 == l.level % 2 ? l.to : l.from);
            if (l = i[o += r], !l) return null;
            s = r > 0 == l.level % 2 ? xi(e, l.to, -1, n) : xi(e, l.from, 1, n)
        }
    }

    function Ci(e, t, r, n) {
        var i = t + r;
        if (n)
            for (; i > 0 && To.test(e.text.charAt(i));) i += r;
        return 0 > i || i > e.text.length ? null : i
    }
    var Li = /gecko\/\d/i.test(navigator.userAgent),
        ki = /MSIE \d/.test(navigator.userAgent),
        Si = ki && (null == document.documentMode || document.documentMode < 8),
        Mi = ki && (null == document.documentMode || document.documentMode < 9),
        Ti = /WebKit\//.test(navigator.userAgent),
        Ai = Ti && /Qt\/\d+\.\d+/.test(navigator.userAgent),
        Ni = /Chrome\//.test(navigator.userAgent),
        Hi = /Opera\//.test(navigator.userAgent),
        Wi = /Apple Computer/.test(navigator.vendor),
        Ei = /KHTML\//.test(navigator.userAgent),
        Di = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent),
        Oi = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent),
        Ii = /PhantomJS/.test(navigator.userAgent),
        zi = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent),
        Pi = zi || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent),
        Fi = zi || /Mac/.test(navigator.platform),
        Ri = /windows/i.test(navigator.platform),
        Vi = Hi && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
    Vi && (Vi = Number(Vi[1])), Vi && Vi >= 15 && (Hi = !1, Ti = !0);
    var Gi, Bi, ji, Ui = Fi && (Ai || Hi && (null == Vi || 12.11 > Vi)),
        Ki = Li || ki && !Mi,
        _i = !1,
        Xi = !1,
        Yi = 0,
        $i = 0,
        qi = 0,
        Zi = null;
    ki ? Zi = -.53 : Li ? Zi = 15 : Ni ? Zi = -.7 : Wi && (Zi = -1 / 3);
    var Ji, Qi, eo = null,
        to = e.changeEnd = function (e) {
            return e.text ? Ut(e.from.line + e.text.length - 1, Yn(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to
        };
    e.Pos = Ut, e.prototype = {
        constructor: e,
        focus: function () {
            window.focus(), dt(this), Wt(this), ct(this)
        },
        setOption: function (e, t) {
            var r = this.options,
                n = r[e];
            (r[e] != t || "mode" == e) && (r[e] = t, ro.hasOwnProperty(e) && ot(this, ro[e])(this, t, n))
        },
        getOption: function (e) {
            return this.options[e]
        },
        getDoc: function () {
            return this.doc
        },
        addKeyMap: function (e, t) {
            this.state.keyMaps[t ? "push" : "unshift"](e)
        },
        removeKeyMap: function (e) {
            for (var t = this.state.keyMaps, r = 0; r < t.length; ++r)
                if (t[r] == e || "string" != typeof t[r] && t[r].name == e) return t.splice(r, 1), !0
        },
        addOverlay: ot(null, function (t, r) {
            var n = t.token ? t : e.getMode(this.options, t);
            if (n.startState) throw new Error("Overlays may not be stateful.");
            this.state.overlays.push({
                mode: n,
                modeSpec: t,
                opaque: r && r.opaque
            }), this.state.modeGen++, at(this)
        }),
        removeOverlay: ot(null, function (e) {
            for (var t = this.state.overlays, r = 0; r < t.length; ++r) {
                var n = t[r].modeSpec;
                if (n == e || "string" == typeof e && n.name == e) return t.splice(r, 1), this.state.modeGen++, at(this), void 0
            }
        }),
        indentLine: ot(null, function (e, t, r) {
            "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), Zt(this.doc, e) && ur(this, e, t, r)
        }),
        indentSelection: ot(null, function (e) {
            var t = this.doc.sel;
            if (Kt(t.from, t.to)) return ur(this, t.from.line, e);
            for (var r = t.to.line - (t.to.ch ? 0 : 1), n = t.from.line; r >= n; ++n) ur(this, n, e)
        }),
        getTokenAt: function (e, t) {
            var r = this.doc;
            e = $t(r, e);
            for (var n = I(this, e.line, t), i = this.doc.mode, o = fn(r, e.line), l = new Cr(o.text, this.options.tabSize); l.pos < e.ch && !l.eol();) {
                l.start = l.pos;
                var s = i.token(l, n)
            }
            return {
                start: l.start,
                end: l.pos,
                string: l.current(),
                className: s || null,
                type: s || null,
                state: n
            }
        },
        getTokenTypeAt: function (e) {
            e = $t(this.doc, e);
            var t = qr(this, fn(this.doc, e.line)),
                r = 0,
                n = (t.length - 1) / 2,
                i = e.ch;
            if (0 == i) return t[2];
            for (;;) {
                var o = r + n >> 1;
                if ((o ? t[2 * o - 1] : 0) >= i) n = o;
                else {
                    if (!(t[2 * o + 1] < i)) return t[2 * o + 2];
                    r = o + 1
                }
            }
        },
        getModeAt: function (t) {
            var r = this.doc.mode;
            return r.innerMode ? e.innerMode(r, this.getTokenAt(t).state).mode : r
        },
        getHelper: function (e, t) {
            if (uo.hasOwnProperty(t)) {
                var r = uo[t],
                    n = this.getModeAt(e);
                return n[t] && r[n[t]] || n.helperType && r[n.helperType] || r[n.name]
            }
        },
        getStateAfter: function (e, t) {
            var r = this.doc;
            return e = Yt(r, null == e ? r.first + r.size - 1 : e), I(this, e + 1, t)
        },
        cursorCoords: function (e, t) {
            var r, n = this.doc.sel;
            return r = null == e ? n.head : "object" == typeof e ? $t(this.doc, e) : e ? n.from : n.to, Z(this, r, t || "page")
        },
        charCoords: function (e, t) {
            return q(this, $t(this.doc, e), t || "page")
        },
        coordsChar: function (e, t) {
            return e = $(this, e, t || "page"), Q(this, e.left, e.top)
        },
        lineAtHeight: function (e, t) {
            return e = $(this, {
                top: e,
                left: 0
            }, t || "page").top, gn(this.doc, e + this.display.viewOffset)
        },
        heightAtLine: function (e, t) {
            var r = !1,
                n = this.doc.first + this.doc.size - 1;
            e < this.doc.first ? e = this.doc.first : e > n && (e = n, r = !0);
            var i = fn(this.doc, e);
            return Y(this, fn(this.doc, e), {
                top: 0,
                left: 0
            }, t || "page").top + (r ? i.height : 0)
        },
        defaultTextHeight: function () {
            return tt(this.display)
        },
        defaultCharWidth: function () {
            return rt(this.display)
        },
        setGutterMarker: ot(null, function (e, t, r) {
            return cr(this, e, function (e) {
                var n = e.gutterMarkers || (e.gutterMarkers = {});
                return n[t] = r, !r && ri(n) && (e.gutterMarkers = null), !0
            })
        }),
        clearGutter: ot(null, function (e) {
            var t = this,
                r = t.doc,
                n = r.first;
            r.iter(function (r) {
                r.gutterMarkers && r.gutterMarkers[e] && (r.gutterMarkers[e] = null, at(t, n, n + 1), ri(r.gutterMarkers) && (r.gutterMarkers = null)), ++n
            })
        }),
        addLineClass: ot(null, function (e, t, r) {
            return cr(this, e, function (e) {
                var n = "text" == t ? "textClass" : "background" == t ? "bgClass" : "wrapClass";
                if (e[n]) {
                    if (new RegExp("(?:^|\\s)" + r + "(?:$|\\s)").test(e[n])) return !1;
                    e[n] += " " + r
                } else e[n] = r;
                return !0
            })
        }),
        removeLineClass: ot(null, function (e, t, r) {
            return cr(this, e, function (e) {
                var n = "text" == t ? "textClass" : "background" == t ? "bgClass" : "wrapClass",
                    i = e[n];
                if (!i) return !1;
                if (null == r) e[n] = null;
                else {
                    var o = i.match(new RegExp("(?:^|\\s+)" + r + "(?:$|\\s+)"));
                    if (!o) return !1;
                    var l = o.index + o[0].length;
                    e[n] = i.slice(0, o.index) + (o.index && l != i.length ? " " : "") + i.slice(l) || null
                }
                return !0
            })
        }),
        addLineWidget: ot(null, function (e, t, r) {
            return Kr(this, e, t, r)
        }),
        removeLineWidget: function (e) {
            e.clear()
        },
        lineInfo: function (e) {
            if ("number" == typeof e) {
                if (!Zt(this.doc, e)) return null;
                var t = e;
                if (e = fn(this.doc, e), !e) return null
            } else {
                var t = mn(e);
                if (null == t) return null
            }
            return {
                line: t,
                handle: e,
                text: e.text,
                gutterMarkers: e.gutterMarkers,
                textClass: e.textClass,
                bgClass: e.bgClass,
                wrapClass: e.wrapClass,
                widgets: e.widgets
            }
        },
        getViewport: function () {
            return {
                from: this.display.showingFrom,
                to: this.display.showingTo
            }
        },
        addWidget: function (e, t, r, n, i) {
            var o = this.display;
            e = Z(this, $t(this.doc, e));
            var l = e.bottom,
                s = e.left;
            if (t.style.position = "absolute", o.sizer.appendChild(t), "over" == n) l = e.top;
            else if ("above" == n || "near" == n) {
                var a = Math.max(o.wrapper.clientHeight, this.doc.height),
                    u = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth);
                ("above" == n || e.bottom + t.offsetHeight > a) && e.top > t.offsetHeight ? l = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= a && (l = e.bottom), s + t.offsetWidth > u && (s = u - t.offsetWidth)
            }
            t.style.top = l + "px", t.style.left = t.style.right = "", "right" == i ? (s = o.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == i ? s = 0 : "middle" == i && (s = (o.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = s + "px"), r && or(this, s, l, s + t.offsetWidth, l + t.offsetHeight)
        },
        triggerOnKeyDown: ot(null, Nt),
        execCommand: function (e) {
            return co[e](this)
        },
        findPosH: function (e, t, r, n) {
            var i = 1;
            0 > t && (i = -1, t = -t);
            for (var o = 0, l = $t(this.doc, e); t > o && (l = fr(this.doc, l, i, r, n), !l.hitSide); ++o);
            return l
        },
        moveH: ot(null, function (e, t) {
            var r, n = this.doc.sel;
            r = n.shift || n.extend || Kt(n.from, n.to) ? fr(this.doc, n.head, e, t, this.options.rtlMoveVisually) : 0 > e ? n.from : n.to, Jt(this.doc, r, r, e)
        }),
        deleteH: ot(null, function (e, t) {
            var r = this.doc.sel;
            Kt(r.from, r.to) ? jt(this.doc, "", r.from, fr(this.doc, r.head, e, t, !1), "+delete") : jt(this.doc, "", r.from, r.to, "+delete"), this.curOp.userSelChange = !0
        }),
        findPosV: function (e, t, r, n) {
            var i = 1,
                o = n;
            0 > t && (i = -1, t = -t);
            for (var l = 0, s = $t(this.doc, e); t > l; ++l) {
                var a = Z(this, s, "div");
                if (null == o ? o = a.left : a.left = o, s = hr(this, a, i, r), s.hitSide) break
            }
            return s
        },
        moveV: ot(null, function (e, t) {
            var r = this.doc.sel,
                n = Z(this, r.head, "div");
            null != r.goalColumn && (n.left = r.goalColumn);
            var i = hr(this, n, e, t);
            "page" == t && ar(this, 0, q(this, i, "div").top - n.top), Jt(this.doc, i, i, e), r.goalColumn = n.left
        }),
        toggleOverwrite: function (e) {
            (null == e || e != this.state.overwrite) && ((this.state.overwrite = !this.state.overwrite) ? this.display.cursor.className += " CodeMirror-overwrite" : this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", ""))
        },
        hasFocus: function () {
            return this.state.focused
        },
        scrollTo: ot(null, function (e, t) {
            sr(this, e, t)
        }),
        getScrollInfo: function () {
            var e = this.display.scroller,
                t = Lo;
            return {
                left: e.scrollLeft,
                top: e.scrollTop,
                height: e.scrollHeight - t,
                width: e.scrollWidth - t,
                clientHeight: e.clientHeight - t,
                clientWidth: e.clientWidth - t
            }
        },
        scrollIntoView: ot(null, function (e, t) {
            "number" == typeof e && (e = Ut(e, 0)), t || (t = 0);
            var r = e;
            e && null == e.line || (this.curOp.scrollToPos = e ? $t(this.doc, e) : this.doc.sel.head, this.curOp.scrollToPosMargin = t, r = Z(this, this.curOp.scrollToPos));
            var n = lr(this, r.left, r.top - t, r.right, r.bottom + t);
            sr(this, n.scrollLeft, n.scrollTop)
        }),
        setSize: ot(null, function (e, t) {
            function r(e) {
                return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e
            }
            null != e && (this.display.wrapper.style.width = r(e)), null != t && (this.display.wrapper.style.height = r(t)), this.options.lineWrapping && (this.display.measureLineCache.length = this.display.measureLineCachePos = 0), this.curOp.forceUpdate = !0
        }),
        operation: function (e) {
            return st(this, e)
        },
        refresh: ot(null, function () {
            K(this), sr(this, this.doc.scrollLeft, this.doc.scrollTop), at(this)
        }),
        swapDoc: ot(null, function (e) {
            var t = this.doc;
            return t.cm = null, cn(this, e), K(this), ht(this, !0), sr(this, e.scrollLeft, e.scrollTop), t
        }),
        getInputField: function () {
            return this.display.input
        },
        getWrapperElement: function () {
            return this.display.wrapper
        },
        getScrollerElement: function () {
            return this.display.scroller
        },
        getGutterElement: function () {
            return this.display.gutters
        }
    }, Un(e);
    var ro = e.optionHandlers = {}, no = e.defaults = {}, io = e.Init = {
            toString: function () {
                return "CodeMirror.Init"
            }
        };
    mr("value", "", function (e, t) {
        e.setValue(t)
    }, !0), mr("mode", null, function (e, t) {
        e.doc.modeOption = t, r(e)
    }, !0), mr("indentUnit", 2, r, !0), mr("indentWithTabs", !1), mr("smartIndent", !0), mr("tabSize", 4, function (e) {
        r(e), K(e), at(e)
    }, !0), mr("electricChars", !0), mr("rtlMoveVisually", !Ri), mr("theme", "default", function (e) {
        s(e), a(e)
    }, !0), mr("keyMap", "default", l), mr("extraKeys", null), mr("onKeyEvent", null), mr("onDragEvent", null), mr("lineWrapping", !1, n, !0), mr("gutters", [], function (e) {
        h(e.options), a(e)
    }, !0), mr("fixedGutter", !0, function (e, t) {
        e.display.gutters.style.left = t ? y(e.display) + "px" : "0", e.refresh()
    }, !0), mr("coverGutterNextToScrollbar", !1, d, !0), mr("lineNumbers", !1, function (e) {
        h(e.options), a(e)
    }, !0), mr("firstLineNumber", 1, a, !0), mr("lineNumberFormatter", function (e) {
        return e
    }, a, !0), mr("showCursorWhenSelecting", !1, A, !0), mr("readOnly", !1, function (e, t) {
        "nocursor" == t ? (Et(e), e.display.input.blur()) : t || ht(e, !0)
    }), mr("dragDrop", !0), mr("cursorBlinkRate", 530), mr("cursorScrollMargin", 0), mr("cursorHeight", 1), mr("workTime", 100), mr("workDelay", 100), mr("flattenSpans", !0), mr("pollInterval", 100), mr("undoDepth", 40, function (e, t) {
        e.doc.history.undoDepth = t
    }), mr("historyEventDelay", 500), mr("viewportMargin", 10, function (e) {
        e.refresh()
    }, !0), mr("maxHighlightLength", 1e4, function (e) {
        r(e), e.refresh()
    }, !0), mr("moveInputWithCursor", !0, function (e, t) {
        t || (e.display.inputDiv.style.top = e.display.inputDiv.style.left = 0)
    }), mr("tabindex", null, function (e, t) {
        e.display.input.tabIndex = t || ""
    }), mr("autofocus", null);
    var oo = e.modes = {}, lo = e.mimeModes = {};
    e.defineMode = function (t, r) {
        if (e.defaults.mode || "null" == t || (e.defaults.mode = t), arguments.length > 2) {
            r.dependencies = [];
            for (var n = 2; n < arguments.length; ++n) r.dependencies.push(arguments[n])
        }
        oo[t] = r
    }, e.defineMIME = function (e, t) {
        lo[e] = t
    }, e.resolveMode = function (t) {
        if ("string" == typeof t && lo.hasOwnProperty(t)) t = lo[t];
        else if (t && "string" == typeof t.name && lo.hasOwnProperty(t.name)) {
            var r = lo[t.name];
            t = Zn(r, t), t.name = r.name
        } else if ("string" == typeof t && /^[\w\-]+\/[\w\-]+\+xml$/.test(t)) return e.resolveMode("application/xml");
        return "string" == typeof t ? {
            name: t
        } : t || {
            name: "null"
        }
    }, e.getMode = function (t, r) {
        var r = e.resolveMode(r),
            n = oo[r.name];
        if (!n) return e.getMode(t, "text/plain");
        var i = n(t, r);
        if (so.hasOwnProperty(r.name)) {
            var o = so[r.name];
            for (var l in o) o.hasOwnProperty(l) && (i.hasOwnProperty(l) && (i["_" + l] = i[l]), i[l] = o[l])
        }
        return i.name = r.name, i
    }, e.defineMode("null", function () {
        return {
            token: function (e) {
                e.skipToEnd()
            }
        }
    }), e.defineMIME("text/plain", "null");
    var so = e.modeExtensions = {};
    e.extendMode = function (e, t) {
        var r = so.hasOwnProperty(e) ? so[e] : so[e] = {};
        Jn(t, r)
    }, e.defineExtension = function (t, r) {
        e.prototype[t] = r
    }, e.defineDocExtension = function (e, t) {
        yo.prototype[e] = t
    }, e.defineOption = mr;
    var ao = [];
    e.defineInitHook = function (e) {
        ao.push(e)
    };
    var uo = e.helpers = {};
    e.registerHelper = function (t, r, n) {
        uo.hasOwnProperty(t) || (uo[t] = e[t] = {}), uo[t][r] = n
    }, e.isWordChar = ti, e.copyState = gr, e.startState = vr, e.innerMode = function (e, t) {
        for (; e.innerMode;) {
            var r = e.innerMode(t);
            if (!r || r.mode == e) break;
            t = r.state, e = r.mode
        }
        return r || {
            mode: e,
            state: t
        }
    };
    var co = e.commands = {
        selectAll: function (e) {
            e.setSelection(Ut(e.firstLine(), 0), Ut(e.lastLine()))
        },
        killLine: function (e) {
            var t = e.getCursor(!0),
                r = e.getCursor(!1),
                n = !Kt(t, r);
            n || e.getLine(t.line).length != t.ch ? e.replaceRange("", t, n ? r : Ut(t.line), "+delete") : e.replaceRange("", t, Ut(t.line + 1, 0), "+delete")
        },
        deleteLine: function (e) {
            var t = e.getCursor().line;
            e.replaceRange("", Ut(t, 0), Ut(t), "+delete")
        },
        delLineLeft: function (e) {
            var t = e.getCursor();
            e.replaceRange("", Ut(t.line, 0), t, "+delete")
        },
        undo: function (e) {
            e.undo()
        },
        redo: function (e) {
            e.redo()
        },
        goDocStart: function (e) {
            e.extendSelection(Ut(e.firstLine(), 0))
        },
        goDocEnd: function (e) {
            e.extendSelection(Ut(e.lastLine()))
        },
        goLineStart: function (e) {
            e.extendSelection(gi(e, e.getCursor().line))
        },
        goLineStartSmart: function (e) {
            var t = e.getCursor(),
                r = gi(e, t.line),
                n = e.getLineHandle(r.line),
                i = yn(n);
            if (i && 0 != i[0].level) e.extendSelection(r);
            else {
                var o = Math.max(0, n.text.search(/\S/)),
                    l = t.line == r.line && t.ch <= o && t.ch;
                e.extendSelection(Ut(r.line, l ? 0 : o))
            }
        },
        goLineEnd: function (e) {
            e.extendSelection(vi(e, e.getCursor().line))
        },
        goLineRight: function (e) {
            var t = e.charCoords(e.getCursor(), "div").top + 5;
            e.extendSelection(e.coordsChar({
                left: e.display.lineDiv.offsetWidth + 100,
                top: t
            }, "div"))
        },
        goLineLeft: function (e) {
            var t = e.charCoords(e.getCursor(), "div").top + 5;
            e.extendSelection(e.coordsChar({
                left: 0,
                top: t
            }, "div"))
        },
        goLineUp: function (e) {
            e.moveV(-1, "line")
        },
        goLineDown: function (e) {
            e.moveV(1, "line")
        },
        goPageUp: function (e) {
            e.moveV(-1, "page")
        },
        goPageDown: function (e) {
            e.moveV(1, "page")
        },
        goCharLeft: function (e) {
            e.moveH(-1, "char")
        },
        goCharRight: function (e) {
            e.moveH(1, "char")
        },
        goColumnLeft: function (e) {
            e.moveH(-1, "column")
        },
        goColumnRight: function (e) {
            e.moveH(1, "column")
        },
        goWordLeft: function (e) {
            e.moveH(-1, "word")
        },
        goGroupRight: function (e) {
            e.moveH(1, "group")
        },
        goGroupLeft: function (e) {
            e.moveH(-1, "group")
        },
        goWordRight: function (e) {
            e.moveH(1, "word")
        },
        delCharBefore: function (e) {
            e.deleteH(-1, "char")
        },
        delCharAfter: function (e) {
            e.deleteH(1, "char")
        },
        delWordBefore: function (e) {
            e.deleteH(-1, "word")
        },
        delWordAfter: function (e) {
            e.deleteH(1, "word")
        },
        delGroupBefore: function (e) {
            e.deleteH(-1, "group")
        },
        delGroupAfter: function (e) {
            e.deleteH(1, "group")
        },
        indentAuto: function (e) {
            e.indentSelection("smart")
        },
        indentMore: function (e) {
            e.indentSelection("add")
        },
        indentLess: function (e) {
            e.indentSelection("subtract")
        },
        insertTab: function (e) {
            e.replaceSelection("   ", "end", "+input")
        },
        defaultTab: function (e) {
            e.somethingSelected() ? e.indentSelection("add") : e.replaceSelection("  ", "end", "+input")
        },
        transposeChars: function (e) {
            var t = e.getCursor(),
                r = e.getLine(t.line);
            t.ch > 0 && t.ch < r.length - 1 && e.replaceRange(r.charAt(t.ch) + r.charAt(t.ch - 1), Ut(t.line, t.ch - 1), Ut(t.line, t.ch + 1))
        },
        newlineAndIndent: function (e) {
            ot(e, function () {
                e.replaceSelection("\n", "end", "+input"), e.indentLine(e.getCursor().line, null, !0)
            })()
        },
        toggleOverwrite: function (e) {
            e.toggleOverwrite()
        }
    }, fo = e.keyMap = {};
    fo.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite"
    }, fo.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Alt-Up": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Down": "goDocEnd",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        fallthrough: "basic"
    }, fo.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineStart",
        "Cmd-Right": "goLineEnd",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delLineLeft",
        fallthrough: ["basic", "emacsy"]
    }, fo["default"] = Fi ? fo.macDefault : fo.pcDefault, fo.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars"
    }, e.lookupKey = br, e.isModifierKey = xr, e.keyName = wr, e.fromTextArea = function (t, r) {
        function n() {
            t.value = u.getValue()
        }
        if (r || (r = {}), r.value = t.value, !r.tabindex && t.tabindex && (r.tabindex = t.tabindex), !r.placeholder && t.placeholder && (r.placeholder = t.placeholder), null == r.autofocus) {
            var i = document.body;
            try {
                i = document.activeElement
            } catch (o) {}
            r.autofocus = i == t || null != t.getAttribute("autofocus") && i == document.body
        }
        if (t.form && (Pn(t.form, "submit", n), !r.leaveSubmitMethodAlone)) {
            var l = t.form,
                s = l.submit;
            try {
                var a = l.submit = function () {
                    n(), l.submit = s, l.submit(), l.submit = a
                }
            } catch (o) {}
        }
        t.style.display = "none";
        var u = e(function (e) {
            t.parentNode.insertBefore(e, t.nextSibling)
        }, r);
        return u.save = n, u.getTextArea = function () {
            return t
        }, u.toTextArea = function () {
            n(), t.parentNode.removeChild(u.getWrapperElement()), t.style.display = "", t.form && (Fn(t.form, "submit", n), "function" == typeof t.form.submit && (t.form.submit = s))
        }, u
    }, Cr.prototype = {
        eol: function () {
            return this.pos >= this.string.length
        },
        sol: function () {
            return 0 == this.pos
        },
        peek: function () {
            return this.string.charAt(this.pos) || void 0
        },
        next: function () {
            return this.pos < this.string.length ? this.string.charAt(this.pos++) : void 0
        },
        eat: function (e) {
            var t = this.string.charAt(this.pos);
            if ("string" == typeof e) var r = t == e;
            else var r = t && (e.test ? e.test(t) : e(t));
            return r ? (++this.pos, t) : void 0
        },
        eatWhile: function (e) {
            for (var t = this.pos; this.eat(e););
            return this.pos > t
        },
        eatSpace: function () {
            for (var e = this.pos;
                /[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;
            return this.pos > e
        },
        skipToEnd: function () {
            this.pos = this.string.length
        },
        skipTo: function (e) {
            var t = this.string.indexOf(e, this.pos);
            return t > -1 ? (this.pos = t, !0) : void 0
        },
        backUp: function (e) {
            this.pos -= e
        },
        column: function () {
            return this.lastColumnPos < this.start && (this.lastColumnValue = _n(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue
        },
        indentation: function () {
            return _n(this.string, null, this.tabSize)
        },
        match: function (e, t, r) {
            if ("string" != typeof e) {
                var n = this.string.slice(this.pos).match(e);
                return n && n.index > 0 ? null : (n && t !== !1 && (this.pos += n[0].length), n)
            }
            var i = function (e) {
                return r ? e.toLowerCase() : e
            }, o = this.string.substr(this.pos, e.length);
            return i(o) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : void 0
        },
        current: function () {
            return this.string.slice(this.start, this.pos)
        }
    }, e.StringStream = Cr, e.TextMarker = Lr, Un(Lr), Lr.prototype.clear = function () {
        if (!this.explicitlyCleared) {
            var e = this.doc.cm,
                t = e && !e.curOp;
            if (t && nt(e), jn(this, "clear")) {
                var r = this.find();
                r && Vn(this, "clear", r.from, r.to)
            }
            for (var n = null, i = null, o = 0; o < this.lines.length; ++o) {
                var l = this.lines[o],
                    s = Tr(l.markedSpans, this);
                null != s.to && (i = mn(l)), l.markedSpans = Ar(l.markedSpans, s), null != s.from ? n = mn(l) : this.collapsed && !Rr(this.doc, l) && e && pn(l, tt(e.display))
            }
            if (e && this.collapsed && !e.options.lineWrapping)
                for (var o = 0; o < this.lines.length; ++o) {
                    var a = Fr(e.doc, this.lines[o]),
                        u = c(e.doc, a);
                    u > e.display.maxLineLength && (e.display.maxLine = a, e.display.maxLineLength = u, e.display.maxLineChanged = !0)
                }
            null != n && e && at(e, n, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && tr(e)), t && it(e)
        }
    }, Lr.prototype.find = function () {
        for (var e, t, r = 0; r < this.lines.length; ++r) {
            var n = this.lines[r],
                i = Tr(n.markedSpans, this);
            if (null != i.from || null != i.to) {
                var o = mn(n);
                null != i.from && (e = Ut(o, i.from)), null != i.to && (t = Ut(o, i.to))
            }
        }
        return "bookmark" == this.type ? e : e && {
            from: e,
            to: t
        }
    }, Lr.prototype.changed = function () {
        var e = this.find(),
            t = this.doc.cm;
        if (e && t) {
            var r = fn(this.doc, e.from.line);
            if (G(t, r), e.from.line >= t.display.showingFrom && e.from.line < t.display.showingTo) {
                for (var n = t.display.lineDiv.firstChild; n; n = n.nextSibling)
                    if (n.lineObj == r) {
                        n.offsetHeight != r.height && pn(r, n.offsetHeight);
                        break
                    }
                st(t, function () {
                    t.curOp.selectionChanged = t.curOp.forceUpdate = t.curOp.updateMaxLine = !0
                })
            }
        }
    }, Lr.prototype.attachLine = function (e) {
        if (!this.lines.length && this.doc.cm) {
            var t = this.doc.cm.curOp;
            t.maybeHiddenMarkers && -1 != qn(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this)
        }
        this.lines.push(e)
    }, Lr.prototype.detachLine = function (e) {
        if (this.lines.splice(qn(this.lines, e), 1), !this.lines.length && this.doc.cm) {
            var t = this.doc.cm.curOp;
            (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this)
        }
    }, e.SharedTextMarker = Sr, Un(Sr), Sr.prototype.clear = function () {
        if (!this.explicitlyCleared) {
            this.explicitlyCleared = !0;
            for (var e = 0; e < this.markers.length; ++e) this.markers[e].clear();
            Vn(this, "clear")
        }
    }, Sr.prototype.find = function () {
        return this.primary.find()
    };
    var ho = e.LineWidget = function (e, t, r) {
        if (r)
            for (var n in r) r.hasOwnProperty(n) && (this[n] = r[n]);
        this.cm = e, this.node = t
    };
    Un(ho), ho.prototype.clear = jr(function () {
        var e = this.line.widgets,
            t = mn(this.line);
        if (null != t && e) {
            for (var r = 0; r < e.length; ++r) e[r] == this && e.splice(r--, 1);
            e.length || (this.line.widgets = null);
            var n = vn(this.cm, this.line) < this.cm.doc.scrollTop;
            pn(this.line, Math.max(0, this.line.height - Ur(this))), n && ar(this.cm, 0, -this.height), at(this.cm, t, t + 1)
        }
    }), ho.prototype.changed = jr(function () {
        var e = this.height;
        this.height = null;
        var t = Ur(this) - e;
        if (t) {
            pn(this.line, this.line.height + t);
            var r = mn(this.line);
            at(this.cm, r, r + 1)
        }
    });
    var po = e.Line = function (e, t, r) {
        this.text = e, Br(this, t), this.height = r ? r(this) : 1
    };
    Un(po);
    var mo = {}, go = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
    sn.prototype = {
        chunkSize: function () {
            return this.lines.length
        },
        removeInner: function (e, t) {
            for (var r = e, n = e + t; n > r; ++r) {
                var i = this.lines[r];
                this.height -= i.height, Xr(i), Vn(i, "delete")
            }
            this.lines.splice(e, t)
        },
        collapse: function (e) {
            e.splice.apply(e, [e.length, 0].concat(this.lines))
        },
        insertInner: function (e, t, r) {
            this.height += r, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
            for (var n = 0, i = t.length; i > n; ++n) t[n].parent = this
        },
        iterN: function (e, t, r) {
            for (var n = e + t; n > e; ++e)
                if (r(this.lines[e])) return !0
        }
    }, an.prototype = {
        chunkSize: function () {
            return this.size
        },
        removeInner: function (e, t) {
            this.size -= t;
            for (var r = 0; r < this.children.length; ++r) {
                var n = this.children[r],
                    i = n.chunkSize();
                if (i > e) {
                    var o = Math.min(t, i - e),
                        l = n.height;
                    if (n.removeInner(e, o), this.height -= l - n.height, i == o && (this.children.splice(r--, 1), n.parent = null), 0 == (t -= o)) break;
                    e = 0
                } else e -= i
            }
            if (this.size - t < 25) {
                var s = [];
                this.collapse(s), this.children = [new sn(s)], this.children[0].parent = this
            }
        },
        collapse: function (e) {
            for (var t = 0, r = this.children.length; r > t; ++t) this.children[t].collapse(e)
        },
        insertInner: function (e, t, r) {
            this.size += t.length, this.height += r;
            for (var n = 0, i = this.children.length; i > n; ++n) {
                var o = this.children[n],
                    l = o.chunkSize();
                if (l >= e) {
                    if (o.insertInner(e, t, r), o.lines && o.lines.length > 50) {
                        for (; o.lines.length > 50;) {
                            var s = o.lines.splice(o.lines.length - 25, 25),
                                a = new sn(s);
                            o.height -= a.height, this.children.splice(n + 1, 0, a), a.parent = this
                        }
                        this.maybeSpill()
                    }
                    break
                }
                e -= l
            }
        },
        maybeSpill: function () {
            if (!(this.children.length <= 10)) {
                var e = this;
                do {
                    var t = e.children.splice(e.children.length - 5, 5),
                        r = new an(t);
                    if (e.parent) {
                        e.size -= r.size, e.height -= r.height;
                        var n = qn(e.parent.children, e);
                        e.parent.children.splice(n + 1, 0, r)
                    } else {
                        var i = new an(e.children);
                        i.parent = e, e.children = [i, r], e = i
                    }
                    r.parent = e.parent
                } while (e.children.length > 10);
                e.parent.maybeSpill()
            }
        },
        iterN: function (e, t, r) {
            for (var n = 0, i = this.children.length; i > n; ++n) {
                var o = this.children[n],
                    l = o.chunkSize();
                if (l > e) {
                    var s = Math.min(t, l - e);
                    if (o.iterN(e, s, r)) return !0;
                    if (0 == (t -= s)) break;
                    e = 0
                } else e -= l
            }
        }
    };
    var vo = 0,
        yo = e.Doc = function (e, t, r) {
            if (!(this instanceof yo)) return new yo(e, t, r);
            null == r && (r = 0), an.call(this, [new sn([new po("", null)])]), this.first = r, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.history = bn(), this.cleanGeneration = 1, this.frontier = r;
            var n = Ut(r, 0);
            this.sel = {
                from: n,
                to: n,
                head: n,
                anchor: n,
                shift: !1,
                extend: !1,
                goalColumn: null
            }, this.id = ++vo, this.modeOption = t, "string" == typeof e && (e = Wo(e)), ln(this, {
                from: n,
                to: n,
                text: e
            }, null, {
                head: n,
                anchor: n
            })
        };
    yo.prototype = Zn(an.prototype, {
        constructor: yo,
        iter: function (e, t, r) {
            r ? this.iterN(e - this.first, t - e, r) : this.iterN(this.first, this.first + this.size, e)
        },
        insert: function (e, t) {
            for (var r = 0, n = 0, i = t.length; i > n; ++n) r += t[n].height;
            this.insertInner(e - this.first, t, r)
        },
        remove: function (e, t) {
            this.removeInner(e - this.first, t)
        },
        getValue: function (e) {
            var t = dn(this, this.first, this.first + this.size);
            return e === !1 ? t : t.join(e || "\n")
        },
        setValue: function (e) {
            var t = Ut(this.first, 0),
                r = this.first + this.size - 1;
            Pt(this, {
                from: t,
                to: Ut(r, fn(this, r).text.length),
                text: Wo(e),
                origin: "setValue"
            }, {
                head: t,
                anchor: t
            }, !0)
        },
        replaceRange: function (e, t, r, n) {
            t = $t(this, t), r = r ? $t(this, r) : t, jt(this, e, t, r, n)
        },
        getRange: function (e, t, r) {
            var n = hn(this, $t(this, e), $t(this, t));
            return r === !1 ? n : n.join(r || "\n")
        },
        getLine: function (e) {
            var t = this.getLineHandle(e);
            return t && t.text
        },
        setLine: function (e, t) {
            Zt(this, e) && jt(this, t, Ut(e, 0), $t(this, Ut(e)))
        },
        removeLine: function (e) {
            e ? jt(this, "", $t(this, Ut(e - 1)), $t(this, Ut(e))) : jt(this, "", Ut(0, 0), $t(this, Ut(1, 0)))
        },
        getLineHandle: function (e) {
            return Zt(this, e) ? fn(this, e) : void 0
        },
        getLineNumber: function (e) {
            return mn(e)
        },
        getLineHandleVisualStart: function (e) {
            return "number" == typeof e && (e = fn(this, e)), Fr(this, e)
        },
        lineCount: function () {
            return this.size
        },
        firstLine: function () {
            return this.first
        },
        lastLine: function () {
            return this.first + this.size - 1
        },
        clipPos: function (e) {
            return $t(this, e)
        },
        getCursor: function (e) {
            var t, r = this.sel;
            return t = null == e || "head" == e ? r.head : "anchor" == e ? r.anchor : "end" == e || e === !1 ? r.to : r.from, Xt(t)
        },
        somethingSelected: function () {
            return !Kt(this.sel.head, this.sel.anchor)
        },
        setCursor: lt(function (e, t, r) {
            var n = $t(this, "number" == typeof e ? Ut(e, t || 0) : e);
            r ? Jt(this, n) : er(this, n, n)
        }),
        setSelection: lt(function (e, t) {
            er(this, $t(this, e), $t(this, t || e))
        }),
        extendSelection: lt(function (e, t) {
            Jt(this, $t(this, e), t && $t(this, t))
        }),
        getSelection: function (e) {
            return this.getRange(this.sel.from, this.sel.to, e)
        },
        replaceSelection: function (e, t, r) {
            Pt(this, {
                from: this.sel.from,
                to: this.sel.to,
                text: Wo(e),
                origin: r
            }, t || "around")
        },
        undo: lt(function () {
            Rt(this, "undo")
        }),
        redo: lt(function () {
            Rt(this, "redo")
        }),
        setExtending: function (e) {
            this.sel.extend = e
        },
        historySize: function () {
            var e = this.history;
            return {
                undo: e.done.length,
                redo: e.undone.length
            }
        },
        clearHistory: function () {
            this.history = bn(this.history.maxGeneration)
        },
        markClean: function () {
            this.cleanGeneration = this.changeGeneration()
        },
        changeGeneration: function () {
            return this.history.lastOp = this.history.lastOrigin = null, this.history.generation
        },
        isClean: function (e) {
            return this.history.generation == (e || this.cleanGeneration)
        },
        getHistory: function () {
            return {
                done: Sn(this.history.done),
                undone: Sn(this.history.undone)
            }
        },
        setHistory: function (e) {
            var t = this.history = bn(this.history.maxGeneration);
            t.done = e.done.slice(0), t.undone = e.undone.slice(0)
        },
        markText: function (e, t, r) {
            return kr(this, $t(this, e), $t(this, t), r, "range")
        },
        setBookmark: function (e, t) {
            var r = {
                replacedWith: t && (null == t.nodeType ? t.widget : t),
                insertLeft: t && t.insertLeft
            };
            return e = $t(this, e), kr(this, e, e, r, "bookmark")
        },
        findMarksAt: function (e) {
            e = $t(this, e);
            var t = [],
                r = fn(this, e.line).markedSpans;
            if (r)
                for (var n = 0; n < r.length; ++n) {
                    var i = r[n];
                    (null == i.from || i.from <= e.ch) && (null == i.to || i.to >= e.ch) && t.push(i.marker.parent || i.marker)
                }
            return t
        },
        getAllMarks: function () {
            var e = [];
            return this.iter(function (t) {
                var r = t.markedSpans;
                if (r)
                    for (var n = 0; n < r.length; ++n) null != r[n].from && e.push(r[n].marker)
            }), e
        },
        posFromIndex: function (e) {
            var t, r = this.first;
            return this.iter(function (n) {
                var i = n.text.length + 1;
                return i > e ? (t = e, !0) : (e -= i, ++r, void 0)
            }), $t(this, Ut(r, t))
        },
        indexFromPos: function (e) {
            e = $t(this, e);
            var t = e.ch;
            return e.line < this.first || e.ch < 0 ? 0 : (this.iter(this.first, e.line, function (e) {
                t += e.text.length + 1
            }), t)
        },
        copy: function (e) {
            var t = new yo(dn(this, this.first, this.first + this.size), this.modeOption, this.first);
            return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = {
                from: this.sel.from,
                to: this.sel.to,
                head: this.sel.head,
                anchor: this.sel.anchor,
                shift: this.sel.shift,
                extend: !1,
                goalColumn: this.sel.goalColumn
            }, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t
        },
        linkedDoc: function (e) {
            e || (e = {});
            var t = this.first,
                r = this.first + this.size;
            null != e.from && e.from > t && (t = e.from), null != e.to && e.to < r && (r = e.to);
            var n = new yo(dn(this, t, r), e.mode || this.modeOption, t);
            return e.sharedHist && (n.history = this.history), (this.linked || (this.linked = [])).push({
                doc: n,
                sharedHist: e.sharedHist
            }), n.linked = [{
                doc: this,
                isParent: !0,
                sharedHist: e.sharedHist
            }], n
        },
        unlinkDoc: function (t) {
            if (t instanceof e && (t = t.doc), this.linked)
                for (var r = 0; r < this.linked.length; ++r) {
                    var n = this.linked[r];
                    if (n.doc == t) {
                        this.linked.splice(r, 1), t.unlinkDoc(this);
                        break
                    }
                }
            if (t.history == this.history) {
                var i = [t.id];
                un(t, function (e) {
                    i.push(e.id)
                }, !0), t.history = bn(), t.history.done = Sn(this.history.done, i), t.history.undone = Sn(this.history.undone, i)
            }
        },
        iterLinkedDocs: function (e) {
            un(this, e)
        },
        getMode: function () {
            return this.mode
        },
        getEditor: function () {
            return this.cm
        }
    }), yo.prototype.eachLine = yo.prototype.iter;
    var bo = "iter insert remove copy getEditor".split(" ");
    for (var xo in yo.prototype) yo.prototype.hasOwnProperty(xo) && qn(bo, xo) < 0 && (e.prototype[xo] = function (e) {
        return function () {
            return e.apply(this.doc, arguments)
        }
    }(yo.prototype[xo]));
    Un(yo), e.e_stop = On, e.e_preventDefault = Wn, e.e_stopPropagation = En;
    var wo, Co = 0;
    e.on = Pn, e.off = Fn, e.signal = Rn;
    var Lo = 30,
        ko = e.Pass = {
            toString: function () {
                return "CodeMirror.Pass"
            }
        };
    Kn.prototype = {
        set: function (e, t) {
            clearTimeout(this.id), this.id = setTimeout(t, e)
        }
    }, e.countColumn = _n;
    var So = [""],
        Mo = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,
        To = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
    e.replaceGetRect = function (e) {
        si = e
    };
    var Ao = function () {
        if (Mi) return !1;
        var e = ni("div");
        return "draggable" in e || "dragDrop" in e
    }();
    Li ? ai = function (e, t) {
        return 36 == e.charCodeAt(t - 1) && 39 == e.charCodeAt(t)
    } : Wi && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent) ? ai = function (e, t) {
        return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(e.slice(t - 1, t + 1))
    } : Ti && !/Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent) && (ai = function (e, t) {
        if (t > 1 && 45 == e.charCodeAt(t - 1)) {
            if (/\w/.test(e.charAt(t - 2)) && /[^\-?\.]/.test(e.charAt(t))) return !0;
            if (t > 2 && /[\d\.,]/.test(e.charAt(t - 2)) && /[\d\.,]/.test(e.charAt(t))) return !1
        }
        return /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|\xe2\x80\xa6[\w~`@#$%\^&*(_=+{[><]/.test(e.slice(t - 1, t + 1))
    });
    var No, Ho, Wo = 3 != "\n\nb".split(/\n/).length ? function (e) {
            for (var t = 0, r = [], n = e.length; n >= t;) {
                var i = e.indexOf("\n", t); - 1 == i && (i = e.length);
                var o = e.slice(t, "\r" == e.charAt(i - 1) ? i - 1 : i),
                    l = o.indexOf("\r"); - 1 != l ? (r.push(o.slice(0, l)), t += l + 1) : (r.push(o), t = i + 1)
            }
            return r
        } : function (e) {
            return e.split(/\r\n?|\n/)
        };
    e.splitLines = Wo;
    var Eo = window.getSelection ? function (e) {
            try {
                return e.selectionStart != e.selectionEnd
            } catch (t) {
                return !1
            }
        } : function (e) {
            try {
                var t = e.ownerDocument.selection.createRange()
            } catch (r) {}
            return t && t.parentElement() == e ? 0 != t.compareEndPoints("StartToEnd", t) : !1
        }, Do = function () {
            var e = ni("div");
            return "oncopy" in e ? !0 : (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy)
        }(),
        Oo = {
            3: "Enter",
            8: "Backspace",
            9: "Tab",
            13: "Enter",
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "PrintScrn",
            45: "Insert",
            46: "Delete",
            59: ";",
            91: "Mod",
            92: "Mod",
            93: "Mod",
            109: "-",
            107: "=",
            127: "Delete",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            63276: "PageUp",
            63277: "PageDown",
            63275: "End",
            63273: "Home",
            63234: "Left",
            63232: "Up",
            63235: "Right",
            63233: "Down",
            63302: "Insert",
            63272: "Delete"
        };
    e.keyNames = Oo,
    function () {
        for (var e = 0; 10 > e; e++) Oo[e + 48] = String(e);
        for (var e = 65; 90 >= e; e++) Oo[e] = String.fromCharCode(e);
        for (var e = 1; 12 >= e; e++) Oo[e + 111] = Oo[e + 63235] = "F" + e
    }();
    var Io, zo = function () {
            function e(e) {
                return 255 >= e ? t.charAt(e) : e >= 1424 && 1524 >= e ? "R" : e >= 1536 && 1791 >= e ? r.charAt(e - 1536) : e >= 1792 && 2220 >= e ? "r" : "L"
            }
            var t = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL",
                r = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr",
                n = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,
                i = /[stwN]/,
                o = /[LRr]/,
                l = /[Lb1n]/,
                s = /[1n]/,
                a = "L";
            return function (t) {
                if (!n.test(t)) return !1;
                for (var r, u = t.length, c = [], f = 0; u > f; ++f) c.push(r = e(t.charCodeAt(f)));
                for (var f = 0, h = a; u > f; ++f) {
                    var r = c[f];
                    "m" == r ? c[f] = h : h = r
                }
                for (var f = 0, d = a; u > f; ++f) {
                    var r = c[f];
                    "1" == r && "r" == d ? c[f] = "n" : o.test(r) && (d = r, "r" == r && (c[f] = "R"))
                }
                for (var f = 1, h = c[0]; u - 1 > f; ++f) {
                    var r = c[f];
                    "+" == r && "1" == h && "1" == c[f + 1] ? c[f] = "1" : "," != r || h != c[f + 1] || "1" != h && "n" != h || (c[f] = h), h = r
                }
                for (var f = 0; u > f; ++f) {
                    var r = c[f];
                    if ("," == r) c[f] = "N";
                    else if ("%" == r) {
                        for (var p = f + 1; u > p && "%" == c[p]; ++p);
                        for (var m = f && "!" == c[f - 1] || u - 1 > p && "1" == c[p] ? "1" : "N", g = f; p > g; ++g) c[g] = m;
                        f = p - 1
                    }
                }
                for (var f = 0, d = a; u > f; ++f) {
                    var r = c[f];
                    "L" == d && "1" == r ? c[f] = "L" : o.test(r) && (d = r)
                }
                for (var f = 0; u > f; ++f)
                    if (i.test(c[f])) {
                        for (var p = f + 1; u > p && i.test(c[p]); ++p);
                        for (var v = "L" == (f ? c[f - 1] : a), y = "L" == (u - 1 > p ? c[p] : a), m = v || y ? "L" : "R", g = f; p > g; ++g) c[g] = m;
                        f = p - 1
                    }
                for (var b, x = [], f = 0; u > f;)
                    if (l.test(c[f])) {
                        var w = f;
                        for (++f; u > f && l.test(c[f]); ++f);
                        x.push({
                            from: w,
                            to: f,
                            level: 0
                        })
                    } else {
                        var C = f,
                            L = x.length;
                        for (++f; u > f && "L" != c[f]; ++f);
                        for (var g = C; f > g;)
                            if (s.test(c[g])) {
                                g > C && x.splice(L, 0, {
                                    from: C,
                                    to: g,
                                    level: 1
                                });
                                var k = g;
                                for (++g; f > g && s.test(c[g]); ++g);
                                x.splice(L, 0, {
                                    from: k,
                                    to: g,
                                    level: 2
                                }), C = g
                            } else ++g;
                        f > C && x.splice(L, 0, {
                            from: C,
                            to: f,
                            level: 1
                        })
                    }
                return 1 == x[0].level && (b = t.match(/^\s+/)) && (x[0].from = b[0].length, x.unshift({
                    from: 0,
                    to: b[0].length,
                    level: 0
                })), 1 == Yn(x).level && (b = t.match(/\s+$/)) && (Yn(x).to -= b[0].length, x.push({
                    from: u - b[0].length,
                    to: u,
                    level: 0
                })), x[0].level != Yn(x).level && x.push({
                    from: u,
                    to: u,
                    level: x[0].level
                }), x
            }
        }();
    return e.version = "3.15.0", e
}(), CodeMirror.defineMode("javascript", function (e, t) {
    function r(e, t, r) {
        return t.tokenize = r, r(e, t)
    }

    function n(e, t) {
        for (var r, n = !1; null != (r = e.next());) {
            if (r == t && !n) return !1;
            n = !n && "\\" == r
        }
        return n
    }

    function i(e, t, r) {
        return U = e, K = r, t
    }

    function o(e, t) {
        var o = e.next();
        if ('"' == o || "'" == o) return r(e, t, l(o));
        if (/[\[\]{}\(\),;\:\.]/.test(o)) return i(o);
        if ("0" == o && e.eat(/x/i)) return e.eatWhile(/[\da-f]/i), i("number", "number");
        if (/\d/.test(o) || "-" == o && e.eat(/\d/)) return e.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), i("number", "number");
        if ("/" == o) return e.eat("*") ? r(e, t, s) : e.eat("/") ? (e.skipToEnd(), i("comment", "comment")) : "operator" == t.lastType || "keyword c" == t.lastType || /^[\[{}\(,;:]$/.test(t.lastType) ? (n(e, "/"), e.eatWhile(/[gimy]/), i("regexp", "string-2")) : (e.eatWhile(Z), i("operator", null, e.current()));
        if ("#" == o) return e.skipToEnd(), i("error", "error");
        if (Z.test(o)) return e.eatWhile(Z), i("operator", null, e.current());
        e.eatWhile(/[\w\$_]/);
        var a = e.current(),
            u = q.propertyIsEnumerable(a) && q[a];
        return u && "." != t.lastType ? i(u.type, u.style, a) : i("variable", "variable", a)
    }

    function l(e) {
        return function (t, r) {
            return n(t, e) || (r.tokenize = o), i("string", "string")
        }
    }

    function s(e, t) {
        for (var r, n = !1; r = e.next();) {
            if ("/" == r && n) {
                t.tokenize = o;
                break
            }
            n = "*" == r
        }
        return i("comment", "comment")
    }

    function a(e, t, r, n, i, o) {
        this.indented = e, this.column = t, this.type = r, this.prev = i, this.info = o, null != n && (this.align = n)
    }

    function u(e, t) {
        for (var r = e.localVars; r; r = r.next)
            if (r.name == t) return !0
    }

    function c(e, t, r, n, i) {
        var o = e.cc;
        for (Q.state = e, Q.stream = i, Q.marked = null, Q.cc = o, e.lexical.hasOwnProperty("align") || (e.lexical.align = !0);;) {
            var l = o.length ? o.pop() : Y ? x : b;
            if (l(r, n)) {
                for (; o.length && o[o.length - 1].lex;) o.pop()();
                return Q.marked ? Q.marked : "variable" == r && u(e, n) ? "variable-2" : t
            }
        }
    }

    function f() {
        for (var e = arguments.length - 1; e >= 0; e--) Q.cc.push(arguments[e])
    }

    function h() {
        return f.apply(null, arguments), !0
    }

    function d(e) {
        function t(t) {
            for (var r = t; r; r = r.next)
                if (r.name == e) return !0;
            return !1
        }
        var r = Q.state;
        if (r.context) {
            if (Q.marked = "def", t(r.localVars)) return;
            r.localVars = {
                name: e,
                next: r.localVars
            }
        } else {
            if (t(r.globalVars)) return;
            r.globalVars = {
                name: e,
                next: r.globalVars
            }
        }
    }

    function p() {
        Q.state.context = {
            prev: Q.state.context,
            vars: Q.state.localVars
        }, Q.state.localVars = et
    }

    function m() {
        Q.state.localVars = Q.state.context.vars, Q.state.context = Q.state.context.prev
    }

    function g(e, t) {
        var r = function () {
            var r = Q.state,
                n = r.indented;
            "stat" == r.lexical.type && (n = r.lexical.indented), r.lexical = new a(n, Q.stream.column(), e, null, r.lexical, t)
        };
        return r.lex = !0, r
    }

    function v() {
        var e = Q.state;
        e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev)
    }

    function y(e) {
        return function (t) {
            return t == e ? h() : ";" == e ? f() : h(arguments.callee)
        }
    }

    function b(e) {
        return "var" == e ? h(g("vardef"), I, y(";"), v) : "keyword a" == e ? h(g("form"), x, b, v) : "keyword b" == e ? h(g("form"), b, v) : "{" == e ? h(g("}"), E, v) : ";" == e ? h() : "if" == e ? h(g("form"), x, b, v, P) : "function" == e ? h(B) : "for" == e ? h(g("form"), y("("), g(")"), F, y(")"), v, b, v) : "variable" == e ? h(g("stat"), T) : "switch" == e ? h(g("form"), x, g("}", "switch"), y("{"), E, v, v) : "case" == e ? h(x, y(":")) : "default" == e ? h(y(":")) : "catch" == e ? h(g("form"), p, y("("), j, y(")"), b, v, m) : f(g("stat"), x, y(";"), v)
    }

    function x(e) {
        return C(e, !1)
    }

    function w(e) {
        return C(e, !0)
    }

    function C(e, t) {
        var r = t ? M : S;
        return J.hasOwnProperty(e) ? h(r) : "function" == e ? h(B) : "keyword c" == e ? h(t ? k : L) : "(" == e ? h(g(")"), L, y(")"), v, r) : "operator" == e ? h(t ? w : x) : "[" == e ? h(g("]"), W(w, "]"), v, r) : "{" == e ? h(g("}"), W(N, "}"), v, r) : h()
    }

    function L(e) {
        return e.match(/[;\}\)\],]/) ? f() : f(x)
    }

    function k(e) {
        return e.match(/[;\}\)\],]/) ? f() : f(w)
    }

    function S(e, t) {
        return "," == e ? h(x) : M(e, t, !1)
    }

    function M(e, t, r) {
        var n = 0 == r ? S : M,
            i = 0 == r ? x : w;
        return "operator" == e ? /\+\+|--/.test(t) ? h(n) : "?" == t ? h(x, y(":"), i) : h(i) : ";" != e ? "(" == e ? h(g(")", "call"), W(w, ")"), v, n) : "." == e ? h(A, n) : "[" == e ? h(g("]"), L, y("]"), v, n) : void 0 : void 0
    }

    function T(e) {
        return ":" == e ? h(v, b) : f(S, y(";"), v)
    }

    function A(e) {
        return "variable" == e ? (Q.marked = "property", h()) : void 0
    }

    function N(e, t) {
        if ("variable" == e) {
            if (Q.marked = "property", "get" == t || "set" == t) return h(H)
        } else("number" == e || "string" == e) && (Q.marked = e + " property");
        return J.hasOwnProperty(e) ? h(y(":"), w) : void 0
    }

    function H(e) {
        return ":" == e ? h(x) : "variable" != e ? h(y(":"), x) : (Q.marked = "property", h(B))
    }

    function W(e, t) {
        function r(n) {
            if ("," == n) {
                var i = Q.state.lexical;
                return "call" == i.info && (i.pos = (i.pos || 0) + 1), h(e, r)
            }
            return n == t ? h() : h(y(t))
        }
        return function (n) {
            return n == t ? h() : f(e, r)
        }
    }

    function E(e) {
        return "}" == e ? h() : f(b, E)
    }

    function D(e) {
        return ":" == e ? h(O) : f()
    }

    function O(e) {
        return "variable" == e ? (Q.marked = "variable-3", h()) : f()
    }

    function I(e, t) {
        return "variable" == e ? (d(t), $ ? h(D, z) : h(z)) : f()
    }

    function z(e, t) {
        return "=" == t ? h(w, z) : "," == e ? h(I) : void 0
    }

    function P(e, t) {
        return "keyword b" == e && "else" == t ? h(g("form"), b, v) : void 0
    }

    function F(e) {
        return "var" == e ? h(I, y(";"), V) : ";" == e ? h(V) : "variable" == e ? h(R) : f(x, y(";"), V)
    }

    function R(e, t) {
        return "in" == t ? h(x) : h(S, V)
    }

    function V(e, t) {
        return ";" == e ? h(G) : "in" == t ? h(x) : f(x, y(";"), G)
    }

    function G(e) {
        ")" != e && h(x)
    }

    function B(e, t) {
        return "variable" == e ? (d(t), h(B)) : "(" == e ? h(g(")"), p, W(j, ")"), v, b, m) : void 0
    }

    function j(e, t) {
        return "variable" == e ? (d(t), $ ? h(D) : h()) : void 0
    }
    var U, K, _ = e.indentUnit,
        X = t.statementIndent,
        Y = t.json,
        $ = t.typescript,
        q = function () {
            function e(e) {
                return {
                    type: e,
                    style: "keyword"
                }
            }
            var t = e("keyword a"),
                r = e("keyword b"),
                n = e("keyword c"),
                i = e("operator"),
                o = {
                    type: "atom",
                    style: "atom"
                }, l = {
                    "if": e("if"),
                    "while": t,
                    "with": t,
                    "else": r,
                    "do": r,
                    "try": r,
                    "finally": r,
                    "return": n,
                    "break": n,
                    "continue": n,
                    "new": n,
                    "delete": n,
                    "throw": n,
                    "var": e("var"),
                    "const": e("var"),
                    let: e("var"),
                    "function": e("function"),
                    "catch": e("catch"),
                    "for": e("for"),
                    "switch": e("switch"),
                    "case": e("case"),
                    "default": e("default"),
                    "in": i,
                    "typeof": i,
                    "instanceof": i,
                    "true": o,
                    "false": o,
                    "null": o,
                    undefined: o,
                    NaN: o,
                    Infinity: o,
                    "this": e("this")
                };
            if ($) {
                var s = {
                    type: "variable",
                    style: "variable-3"
                }, a = {
                        "interface": e("interface"),
                        "class": e("class"),
                        "extends": e("extends"),
                        constructor: e("constructor"),
                        "public": e("public"),
                        "private": e("private"),
                        "protected": e("protected"),
                        "static": e("static"),
                        "super": e("super"),
                        string: s,
                        number: s,
                        bool: s,
                        any: s
                    };
                for (var u in a) l[u] = a[u]
            }
            return l
        }(),
        Z = /[+\-*&%=<>!?|~^]/,
        J = {
            atom: !0,
            number: !0,
            variable: !0,
            string: !0,
            regexp: !0,
            "this": !0
        }, Q = {
            state: null,
            column: null,
            marked: null,
            cc: null
        }, et = {
            name: "this",
            next: {
                name: "arguments"
            }
        };
    return v.lex = !0, {
        startState: function (e) {
            return {
                tokenize: o,
                lastType: null,
                cc: [],
                lexical: new a((e || 0) - _, 0, "block", !1),
                localVars: t.localVars,
                globalVars: t.globalVars,
                context: t.localVars && {
                    vars: t.localVars
                },
                indented: 0
            }
        },
        token: function (e, t) {
            if (e.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1), t.indented = e.indentation()), t.tokenize != s && e.eatSpace()) return null;
            var r = t.tokenize(e, t);
            return "comment" == U ? r : (t.lastType = "operator" != U || "++" != K && "--" != K ? U : "incdec", c(t, r, U, K, e))
        },
        indent: function (e, r) {
            if (e.tokenize == s) return CodeMirror.Pass;
            if (e.tokenize != o) return 0;
            for (var n = r && r.charAt(0), i = e.lexical, l = e.cc.length - 1; l >= 0; --l) {
                var a = e.cc[l];
                if (a == v) i = i.prev;
                else if (a != P || /^else\b/.test(r)) break
            }
            "stat" == i.type && "}" == n && (i = i.prev), X && ")" == i.type && "stat" == i.prev.type && (i = i.prev);
            var u = i.type,
                c = n == u;
            return "vardef" == u ? i.indented + ("operator" == e.lastType || "," == e.lastType ? 4 : 0) : "form" == u && "{" == n ? i.indented : "form" == u ? i.indented + _ : "stat" == u ? i.indented + ("operator" == e.lastType || "," == e.lastType ? X || _ : 0) : "switch" != i.info || c || 0 == t.doubleIndentSwitch ? i.align ? i.column + (c ? 0 : 1) : i.indented + (c ? 0 : _) : i.indented + (/^(?:case|default)\b/.test(r) ? _ : 2 * _)
        },
        electricChars: ":{}",
        blockCommentStart: Y ? null : "/*",
        blockCommentEnd: Y ? null : "*/",
        lineComment: Y ? null : "//",
        fold: "brace",
        helperType: Y ? "json" : "javascript",
        jsonMode: Y
    }
}), CodeMirror.defineMIME("text/javascript", "javascript"), CodeMirror.defineMIME("text/ecmascript", "javascript"), CodeMirror.defineMIME("application/javascript", "javascript"), CodeMirror.defineMIME("application/ecmascript", "javascript"), CodeMirror.defineMIME("application/json", {
    name: "javascript",
    json: !0
}), CodeMirror.defineMIME("application/x-json", {
    name: "javascript",
    json: !0
}), CodeMirror.defineMIME("text/typescript", {
    name: "javascript",
    typescript: !0
}), CodeMirror.defineMIME("application/typescript", {
    name: "javascript",
    typescript: !0
});
var NUM_TEXTS = [null, "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten"],
    editor = null,
    worker = null,
    cache = {
        toggled: {
            configure: !1,
            output: !0
        }
    }, prefs = restore("prefs") || {
        opts: {
            forin: !0,
            noarg: !0,
            bitwise: !0,
            nonew: !0,
            strict: !1,
            browser: !0,
            devel: !0,
            node: !1,
            jquery: !1,
            esnext: !1,
            moz: !1,
            es3: !1
        },
        rev: {
            eqnull: !0,
            debug: !0,
            boss: !0,
            evil: !0,
            loopfunc: !0,
            laxbreak: !0
        },
        meta: {
            unused: !0,
            undef: !0,
            complex: !0
        }
    };